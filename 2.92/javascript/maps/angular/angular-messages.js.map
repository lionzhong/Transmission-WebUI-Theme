{"version":3,"sources":["angular/angular-messages.js"],"names":["window","angular","ngMessageDirectiveFactory","contains","collection","key","isArray","indexOf","hasOwnProperty","$animate","restrict","transclude","priority","terminal","require","link","scope","element","attrs","ngMessagesCtrl","$transclude","records","commentNode","staticExp","ngMessage","when","dynamicExp","ngMessageExp","whenExp","assignRecords","items","split","reRender","$eval","$watchCollection","currentElement","messageCtrl","register","test","name","attach","elm","newScope","enter","$$attachId","getAttachId","on","deregister","detach","$destroy","leave","forEach","isString","jqLite","module","directive","isAttrTruthy","attr","length","truthy","val","ACTIVE_CLASS","INACTIVE_CLASS","controller","$element","$scope","$attrs","findPreviousMessage","parent","comment","prevNode","parentLookup","prevKey","$$ngMessageNode","messages","childNodes","push","previousSibling","parentNode","insertMessageNode","messageNode","ctrl","head","match","next","removeMessageNode","this","latestKey","nextAttachId","renderLater","cachedCollection","render","multiple","ngMessagesMultiple","unmatchedMessages","matchedKeys","messageItem","messageFound","totalMessages","message","messageUsed","value","setClass","ngMessages","item","$evalAsync","nextKey","toString","$templateRequest","$document","$compile","replaceElementWithMarker","src","$$createComment","createComment","marker","after","remove","ngMessagesInclude","then","html","$$destroyed","trim","contents"],"mappings":"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","file":"../../angular/angular-messages.js","sourcesContent":["/**\r\n * @license AngularJS v1.6.2\r\n * (c) 2010-2017 Google, Inc. http://angularjs.org\r\n * License: MIT\r\n */\r\n(function(window, angular) {'use strict';\r\n\r\nvar forEach;\r\nvar isArray;\r\nvar isString;\r\nvar jqLite;\r\n\r\n/**\r\n * @ngdoc module\r\n * @name ngMessages\r\n * @description\r\n *\r\n * The `ngMessages` module provides enhanced support for displaying messages within templates\r\n * (typically within forms or when rendering message objects that return key/value data).\r\n * Instead of relying on JavaScript code and/or complex ng-if statements within your form template to\r\n * show and hide error messages specific to the state of an input field, the `ngMessages` and\r\n * `ngMessage` directives are designed to handle the complexity, inheritance and priority\r\n * sequencing based on the order of how the messages are defined in the template.\r\n *\r\n * Currently, the ngMessages module only contains the code for the `ngMessages`, `ngMessagesInclude`\r\n * `ngMessage` and `ngMessageExp` directives.\r\n *\r\n * # Usage\r\n * The `ngMessages` directive allows keys in a key/value collection to be associated with a child element\r\n * (or 'message') that will show or hide based on the truthiness of that key's value in the collection. A common use\r\n * case for `ngMessages` is to display error messages for inputs using the `$error` object exposed by the\r\n * {@link ngModel ngModel} directive.\r\n *\r\n * The child elements of the `ngMessages` directive are matched to the collection keys by a `ngMessage` or\r\n * `ngMessageExp` directive. The value of these attributes must match a key in the collection that is provided by\r\n * the `ngMessages` directive.\r\n *\r\n * Consider the following example, which illustrates a typical use case of `ngMessages`. Within the form `myForm` we\r\n * have a text input named `myField` which is bound to the scope variable `field` using the {@link ngModel ngModel}\r\n * directive.\r\n *\r\n * The `myField` field is a required input of type `email` with a maximum length of 15 characters.\r\n *\r\n * ```html\r\n * <form name=\"myForm\">\r\n *   <label>\r\n *     Enter text:\r\n *     <input type=\"email\" ng-model=\"field\" name=\"myField\" required maxlength=\"15\" />\r\n *   </label>\r\n *   <div ng-messages=\"myForm.myField.$error\" role=\"alert\">\r\n *     <div ng-message=\"required\">Please enter a value for this field.</div>\r\n *     <div ng-message=\"email\">This field must be a valid email address.</div>\r\n *     <div ng-message=\"maxlength\">This field can be at most 15 characters long.</div>\r\n *   </div>\r\n * </form>\r\n * ```\r\n *\r\n * In order to show error messages corresponding to `myField` we first create an element with an `ngMessages` attribute\r\n * set to the `$error` object owned by the `myField` input in our `myForm` form.\r\n *\r\n * Within this element we then create separate elements for each of the possible errors that `myField` could have.\r\n * The `ngMessage` attribute is used to declare which element(s) will appear for which error - for example,\r\n * setting `ng-message=\"required\"` specifies that this particular element should be displayed when there\r\n * is no value present for the required field `myField` (because the key `required` will be `true` in the object\r\n * `myForm.myField.$error`).\r\n *\r\n * ### Message order\r\n *\r\n * By default, `ngMessages` will only display one message for a particular key/value collection at any time. If more\r\n * than one message (or error) key is currently true, then which message is shown is determined by the order of messages\r\n * in the HTML template code (messages declared first are prioritised). This mechanism means the developer does not have\r\n * to prioritize messages using custom JavaScript code.\r\n *\r\n * Given the following error object for our example (which informs us that the field `myField` currently has both the\r\n * `required` and `email` errors):\r\n *\r\n * ```javascript\r\n * <!-- keep in mind that ngModel automatically sets these error flags -->\r\n * myField.$error = { required : true, email: true, maxlength: false };\r\n * ```\r\n * The `required` message will be displayed to the user since it appears before the `email` message in the DOM.\r\n * Once the user types a single character, the `required` message will disappear (since the field now has a value)\r\n * but the `email` message will be visible because it is still applicable.\r\n *\r\n * ### Displaying multiple messages at the same time\r\n *\r\n * While `ngMessages` will by default only display one error element at a time, the `ng-messages-multiple` attribute can\r\n * be applied to the `ngMessages` container element to cause it to display all applicable error messages at once:\r\n *\r\n * ```html\r\n * <!-- attribute-style usage -->\r\n * <div ng-messages=\"myForm.myField.$error\" ng-messages-multiple>...</div>\r\n *\r\n * <!-- element-style usage -->\r\n * <ng-messages for=\"myForm.myField.$error\" multiple>...</ng-messages>\r\n * ```\r\n *\r\n * ## Reusing and Overriding Messages\r\n * In addition to prioritization, ngMessages also allows for including messages from a remote or an inline\r\n * template. This allows for generic collection of messages to be reused across multiple parts of an\r\n * application.\r\n *\r\n * ```html\r\n * <script type=\"text/ng-template\" id=\"error-messages\">\r\n *   <div ng-message=\"required\">This field is required</div>\r\n *   <div ng-message=\"minlength\">This field is too short</div>\r\n * </script>\r\n *\r\n * <div ng-messages=\"myForm.myField.$error\" role=\"alert\">\r\n *   <div ng-messages-include=\"error-messages\"></div>\r\n * </div>\r\n * ```\r\n *\r\n * However, including generic messages may not be useful enough to match all input fields, therefore,\r\n * `ngMessages` provides the ability to override messages defined in the remote template by redefining\r\n * them within the directive container.\r\n *\r\n * ```html\r\n * <!-- a generic template of error messages known as \"my-custom-messages\" -->\r\n * <script type=\"text/ng-template\" id=\"my-custom-messages\">\r\n *   <div ng-message=\"required\">This field is required</div>\r\n *   <div ng-message=\"minlength\">This field is too short</div>\r\n * </script>\r\n *\r\n * <form name=\"myForm\">\r\n *   <label>\r\n *     Email address\r\n *     <input type=\"email\"\r\n *            id=\"email\"\r\n *            name=\"myEmail\"\r\n *            ng-model=\"email\"\r\n *            minlength=\"5\"\r\n *            required />\r\n *   </label>\r\n *   <!-- any ng-message elements that appear BEFORE the ng-messages-include will\r\n *        override the messages present in the ng-messages-include template -->\r\n *   <div ng-messages=\"myForm.myEmail.$error\" role=\"alert\">\r\n *     <!-- this required message has overridden the template message -->\r\n *     <div ng-message=\"required\">You did not enter your email address</div>\r\n *\r\n *     <!-- this is a brand new message and will appear last in the prioritization -->\r\n *     <div ng-message=\"email\">Your email address is invalid</div>\r\n *\r\n *     <!-- and here are the generic error messages -->\r\n *     <div ng-messages-include=\"my-custom-messages\"></div>\r\n *   </div>\r\n * </form>\r\n * ```\r\n *\r\n * In the example HTML code above the message that is set on required will override the corresponding\r\n * required message defined within the remote template. Therefore, with particular input fields (such\r\n * email addresses, date fields, autocomplete inputs, etc...), specialized error messages can be applied\r\n * while more generic messages can be used to handle other, more general input errors.\r\n *\r\n * ## Dynamic Messaging\r\n * ngMessages also supports using expressions to dynamically change key values. Using arrays and\r\n * repeaters to list messages is also supported. This means that the code below will be able to\r\n * fully adapt itself and display the appropriate message when any of the expression data changes:\r\n *\r\n * ```html\r\n * <form name=\"myForm\">\r\n *   <label>\r\n *     Email address\r\n *     <input type=\"email\"\r\n *            name=\"myEmail\"\r\n *            ng-model=\"email\"\r\n *            minlength=\"5\"\r\n *            required />\r\n *   </label>\r\n *   <div ng-messages=\"myForm.myEmail.$error\" role=\"alert\">\r\n *     <div ng-message=\"required\">You did not enter your email address</div>\r\n *     <div ng-repeat=\"errorMessage in errorMessages\">\r\n *       <!-- use ng-message-exp for a message whose key is given by an expression -->\r\n *       <div ng-message-exp=\"errorMessage.type\">{{ errorMessage.text }}</div>\r\n *     </div>\r\n *   </div>\r\n * </form>\r\n * ```\r\n *\r\n * The `errorMessage.type` expression can be a string value or it can be an array so\r\n * that multiple errors can be associated with a single error message:\r\n *\r\n * ```html\r\n *   <label>\r\n *     Email address\r\n *     <input type=\"email\"\r\n *            ng-model=\"data.email\"\r\n *            name=\"myEmail\"\r\n *            ng-minlength=\"5\"\r\n *            ng-maxlength=\"100\"\r\n *            required />\r\n *   </label>\r\n *   <div ng-messages=\"myForm.myEmail.$error\" role=\"alert\">\r\n *     <div ng-message-exp=\"'required'\">You did not enter your email address</div>\r\n *     <div ng-message-exp=\"['minlength', 'maxlength']\">\r\n *       Your email must be between 5 and 100 characters long\r\n *     </div>\r\n *   </div>\r\n * ```\r\n *\r\n * Feel free to use other structural directives such as ng-if and ng-switch to further control\r\n * what messages are active and when. Be careful, if you place ng-message on the same element\r\n * as these structural directives, Angular may not be able to determine if a message is active\r\n * or not. Therefore it is best to place the ng-message on a child element of the structural\r\n * directive.\r\n *\r\n * ```html\r\n * <div ng-messages=\"myForm.myEmail.$error\" role=\"alert\">\r\n *   <div ng-if=\"showRequiredError\">\r\n *     <div ng-message=\"required\">Please enter something</div>\r\n *   </div>\r\n * </div>\r\n * ```\r\n *\r\n * ## Animations\r\n * If the `ngAnimate` module is active within the application then the `ngMessages`, `ngMessage` and\r\n * `ngMessageExp` directives will trigger animations whenever any messages are added and removed from\r\n * the DOM by the `ngMessages` directive.\r\n *\r\n * Whenever the `ngMessages` directive contains one or more visible messages then the `.ng-active` CSS\r\n * class will be added to the element. The `.ng-inactive` CSS class will be applied when there are no\r\n * messages present. Therefore, CSS transitions and keyframes as well as JavaScript animations can\r\n * hook into the animations whenever these classes are added/removed.\r\n *\r\n * Let's say that our HTML code for our messages container looks like so:\r\n *\r\n * ```html\r\n * <div ng-messages=\"myMessages\" class=\"my-messages\" role=\"alert\">\r\n *   <div ng-message=\"alert\" class=\"some-message\">...</div>\r\n *   <div ng-message=\"fail\" class=\"some-message\">...</div>\r\n * </div>\r\n * ```\r\n *\r\n * Then the CSS animation code for the message container looks like so:\r\n *\r\n * ```css\r\n * .my-messages {\r\n *   transition:1s linear all;\r\n * }\r\n * .my-messages.ng-active {\r\n *   // messages are visible\r\n * }\r\n * .my-messages.ng-inactive {\r\n *   // messages are hidden\r\n * }\r\n * ```\r\n *\r\n * Whenever an inner message is attached (becomes visible) or removed (becomes hidden) then the enter\r\n * and leave animation is triggered for each particular element bound to the `ngMessage` directive.\r\n *\r\n * Therefore, the CSS code for the inner messages looks like so:\r\n *\r\n * ```css\r\n * .some-message {\r\n *   transition:1s linear all;\r\n * }\r\n *\r\n * .some-message.ng-enter {}\r\n * .some-message.ng-enter.ng-enter-active {}\r\n *\r\n * .some-message.ng-leave {}\r\n * .some-message.ng-leave.ng-leave-active {}\r\n * ```\r\n *\r\n * {@link ngAnimate Click here} to learn how to use JavaScript animations or to learn more about ngAnimate.\r\n */\r\nangular.module('ngMessages', [], function initAngularHelpers() {\r\n  // Access helpers from angular core.\r\n  // Do it inside a `config` block to ensure `window.angular` is available.\r\n  forEach = angular.forEach;\r\n  isArray = angular.isArray;\r\n  isString = angular.isString;\r\n  jqLite = angular.element;\r\n})\r\n\r\n  /**\r\n   * @ngdoc directive\r\n   * @module ngMessages\r\n   * @name ngMessages\r\n   * @restrict AE\r\n   *\r\n   * @description\r\n   * `ngMessages` is a directive that is designed to show and hide messages based on the state\r\n   * of a key/value object that it listens on. The directive itself complements error message\r\n   * reporting with the `ngModel` $error object (which stores a key/value state of validation errors).\r\n   *\r\n   * `ngMessages` manages the state of internal messages within its container element. The internal\r\n   * messages use the `ngMessage` directive and will be inserted/removed from the page depending\r\n   * on if they're present within the key/value object. By default, only one message will be displayed\r\n   * at a time and this depends on the prioritization of the messages within the template. (This can\r\n   * be changed by using the `ng-messages-multiple` or `multiple` attribute on the directive container.)\r\n   *\r\n   * A remote template can also be used to promote message reusability and messages can also be\r\n   * overridden.\r\n   *\r\n   * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.\r\n   *\r\n   * @usage\r\n   * ```html\r\n   * <!-- using attribute directives -->\r\n   * <ANY ng-messages=\"expression\" role=\"alert\">\r\n   *   <ANY ng-message=\"stringValue\">...</ANY>\r\n   *   <ANY ng-message=\"stringValue1, stringValue2, ...\">...</ANY>\r\n   *   <ANY ng-message-exp=\"expressionValue\">...</ANY>\r\n   * </ANY>\r\n   *\r\n   * <!-- or by using element directives -->\r\n   * <ng-messages for=\"expression\" role=\"alert\">\r\n   *   <ng-message when=\"stringValue\">...</ng-message>\r\n   *   <ng-message when=\"stringValue1, stringValue2, ...\">...</ng-message>\r\n   *   <ng-message when-exp=\"expressionValue\">...</ng-message>\r\n   * </ng-messages>\r\n   * ```\r\n   *\r\n   * @param {string} ngMessages an angular expression evaluating to a key/value object\r\n   *                 (this is typically the $error object on an ngModel instance).\r\n   * @param {string=} ngMessagesMultiple|multiple when set, all messages will be displayed with true\r\n   *\r\n   * @example\r\n   * <example name=\"ngMessages-directive\" module=\"ngMessagesExample\"\r\n   *          deps=\"angular-messages.js\"\r\n   *          animations=\"true\" fixBase=\"true\">\r\n   *   <file name=\"index.html\">\r\n   *     <form name=\"myForm\">\r\n   *       <label>\r\n   *         Enter your name:\r\n   *         <input type=\"text\"\r\n   *                name=\"myName\"\r\n   *                ng-model=\"name\"\r\n   *                ng-minlength=\"5\"\r\n   *                ng-maxlength=\"20\"\r\n   *                required />\r\n   *       </label>\r\n   *       <pre>myForm.myName.$error = {{ myForm.myName.$error | json }}</pre>\r\n   *\r\n   *       <div ng-messages=\"myForm.myName.$error\" style=\"color:maroon\" role=\"alert\">\r\n   *         <div ng-message=\"required\">You did not enter a field</div>\r\n   *         <div ng-message=\"minlength\">Your field is too short</div>\r\n   *         <div ng-message=\"maxlength\">Your field is too long</div>\r\n   *       </div>\r\n   *     </form>\r\n   *   </file>\r\n   *   <file name=\"script.js\">\r\n   *     angular.module('ngMessagesExample', ['ngMessages']);\r\n   *   </file>\r\n   * </example>\r\n   */\r\n  .directive('ngMessages', ['$animate', function($animate) {\r\n    var ACTIVE_CLASS = 'ng-active';\r\n    var INACTIVE_CLASS = 'ng-inactive';\r\n\r\n    return {\r\n      require: 'ngMessages',\r\n      restrict: 'AE',\r\n      controller: ['$element', '$scope', '$attrs', function NgMessagesCtrl($element, $scope, $attrs) {\r\n        var ctrl = this;\r\n        var latestKey = 0;\r\n        var nextAttachId = 0;\r\n\r\n        this.getAttachId = function getAttachId() { return nextAttachId++; };\r\n\r\n        var messages = this.messages = {};\r\n        var renderLater, cachedCollection;\r\n\r\n        this.render = function(collection) {\r\n          collection = collection || {};\r\n\r\n          renderLater = false;\r\n          cachedCollection = collection;\r\n\r\n          // this is true if the attribute is empty or if the attribute value is truthy\r\n          var multiple = isAttrTruthy($scope, $attrs.ngMessagesMultiple) ||\r\n                         isAttrTruthy($scope, $attrs.multiple);\r\n\r\n          var unmatchedMessages = [];\r\n          var matchedKeys = {};\r\n          var messageItem = ctrl.head;\r\n          var messageFound = false;\r\n          var totalMessages = 0;\r\n\r\n          // we use != instead of !== to allow for both undefined and null values\r\n          while (messageItem != null) {\r\n            totalMessages++;\r\n            var messageCtrl = messageItem.message;\r\n\r\n            var messageUsed = false;\r\n            if (!messageFound) {\r\n              forEach(collection, function(value, key) {\r\n                if (!messageUsed && truthy(value) && messageCtrl.test(key)) {\r\n                  // this is to prevent the same error name from showing up twice\r\n                  if (matchedKeys[key]) return;\r\n                  matchedKeys[key] = true;\r\n\r\n                  messageUsed = true;\r\n                  messageCtrl.attach();\r\n                }\r\n              });\r\n            }\r\n\r\n            if (messageUsed) {\r\n              // unless we want to display multiple messages then we should\r\n              // set a flag here to avoid displaying the next message in the list\r\n              messageFound = !multiple;\r\n            } else {\r\n              unmatchedMessages.push(messageCtrl);\r\n            }\r\n\r\n            messageItem = messageItem.next;\r\n          }\r\n\r\n          forEach(unmatchedMessages, function(messageCtrl) {\r\n            messageCtrl.detach();\r\n          });\r\n\r\n          if (unmatchedMessages.length !== totalMessages) {\r\n            $animate.setClass($element, ACTIVE_CLASS, INACTIVE_CLASS);\r\n          } else {\r\n            $animate.setClass($element, INACTIVE_CLASS, ACTIVE_CLASS);\r\n          }\r\n        };\r\n\r\n        $scope.$watchCollection($attrs.ngMessages || $attrs['for'], ctrl.render);\r\n\r\n        // If the element is destroyed, proactively destroy all the currently visible messages\r\n        $element.on('$destroy', function() {\r\n          forEach(messages, function(item) {\r\n            item.message.detach();\r\n          });\r\n        });\r\n\r\n        this.reRender = function() {\r\n          if (!renderLater) {\r\n            renderLater = true;\r\n            $scope.$evalAsync(function() {\r\n              if (renderLater && cachedCollection) {\r\n                ctrl.render(cachedCollection);\r\n              }\r\n            });\r\n          }\r\n        };\r\n\r\n        this.register = function(comment, messageCtrl) {\r\n          var nextKey = latestKey.toString();\r\n          messages[nextKey] = {\r\n            message: messageCtrl\r\n          };\r\n          insertMessageNode($element[0], comment, nextKey);\r\n          comment.$$ngMessageNode = nextKey;\r\n          latestKey++;\r\n\r\n          ctrl.reRender();\r\n        };\r\n\r\n        this.deregister = function(comment) {\r\n          var key = comment.$$ngMessageNode;\r\n          delete comment.$$ngMessageNode;\r\n          removeMessageNode($element[0], comment, key);\r\n          delete messages[key];\r\n          ctrl.reRender();\r\n        };\r\n\r\n        function findPreviousMessage(parent, comment) {\r\n          var prevNode = comment;\r\n          var parentLookup = [];\r\n\r\n          while (prevNode && prevNode !== parent) {\r\n            var prevKey = prevNode.$$ngMessageNode;\r\n            if (prevKey && prevKey.length) {\r\n              return messages[prevKey];\r\n            }\r\n\r\n            // dive deeper into the DOM and examine its children for any ngMessage\r\n            // comments that may be in an element that appears deeper in the list\r\n            if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) === -1) {\r\n              parentLookup.push(prevNode);\r\n              prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];\r\n            } else if (prevNode.previousSibling) {\r\n              prevNode = prevNode.previousSibling;\r\n            } else {\r\n              prevNode = prevNode.parentNode;\r\n              parentLookup.push(prevNode);\r\n            }\r\n          }\r\n        }\r\n\r\n        function insertMessageNode(parent, comment, key) {\r\n          var messageNode = messages[key];\r\n          if (!ctrl.head) {\r\n            ctrl.head = messageNode;\r\n          } else {\r\n            var match = findPreviousMessage(parent, comment);\r\n            if (match) {\r\n              messageNode.next = match.next;\r\n              match.next = messageNode;\r\n            } else {\r\n              messageNode.next = ctrl.head;\r\n              ctrl.head = messageNode;\r\n            }\r\n          }\r\n        }\r\n\r\n        function removeMessageNode(parent, comment, key) {\r\n          var messageNode = messages[key];\r\n\r\n          var match = findPreviousMessage(parent, comment);\r\n          if (match) {\r\n            match.next = messageNode.next;\r\n          } else {\r\n            ctrl.head = messageNode.next;\r\n          }\r\n        }\r\n      }]\r\n    };\r\n\r\n    function isAttrTruthy(scope, attr) {\r\n     return (isString(attr) && attr.length === 0) || //empty attribute\r\n            truthy(scope.$eval(attr));\r\n    }\r\n\r\n    function truthy(val) {\r\n      return isString(val) ? val.length : !!val;\r\n    }\r\n  }])\r\n\r\n  /**\r\n   * @ngdoc directive\r\n   * @name ngMessagesInclude\r\n   * @restrict AE\r\n   * @scope\r\n   *\r\n   * @description\r\n   * `ngMessagesInclude` is a directive with the purpose to import existing ngMessage template\r\n   * code from a remote template and place the downloaded template code into the exact spot\r\n   * that the ngMessagesInclude directive is placed within the ngMessages container. This allows\r\n   * for a series of pre-defined messages to be reused and also allows for the developer to\r\n   * determine what messages are overridden due to the placement of the ngMessagesInclude directive.\r\n   *\r\n   * @usage\r\n   * ```html\r\n   * <!-- using attribute directives -->\r\n   * <ANY ng-messages=\"expression\" role=\"alert\">\r\n   *   <ANY ng-messages-include=\"remoteTplString\">...</ANY>\r\n   * </ANY>\r\n   *\r\n   * <!-- or by using element directives -->\r\n   * <ng-messages for=\"expression\" role=\"alert\">\r\n   *   <ng-messages-include src=\"expressionValue1\">...</ng-messages-include>\r\n   * </ng-messages>\r\n   * ```\r\n   *\r\n   * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.\r\n   *\r\n   * @param {string} ngMessagesInclude|src a string value corresponding to the remote template.\r\n   */\r\n  .directive('ngMessagesInclude',\r\n    ['$templateRequest', '$document', '$compile', function($templateRequest, $document, $compile) {\r\n\r\n    return {\r\n      restrict: 'AE',\r\n      require: '^^ngMessages', // we only require this for validation sake\r\n      link: function($scope, element, attrs) {\r\n        var src = attrs.ngMessagesInclude || attrs.src;\r\n        $templateRequest(src).then(function(html) {\r\n          if ($scope.$$destroyed) return;\r\n\r\n          if (isString(html) && !html.trim()) {\r\n            // Empty template - nothing to compile\r\n            replaceElementWithMarker(element, src);\r\n          } else {\r\n            // Non-empty template - compile and link\r\n            $compile(html)($scope, function(contents) {\r\n              element.after(contents);\r\n              replaceElementWithMarker(element, src);\r\n            });\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n    // Helpers\r\n    function replaceElementWithMarker(element, src) {\r\n      // A comment marker is placed for debugging purposes\r\n      var comment = $compile.$$createComment ?\r\n          $compile.$$createComment('ngMessagesInclude', src) :\r\n          $document[0].createComment(' ngMessagesInclude: ' + src + ' ');\r\n      var marker = jqLite(comment);\r\n      element.after(marker);\r\n\r\n      // Don't pollute the DOM anymore by keeping an empty directive element\r\n      element.remove();\r\n    }\r\n  }])\r\n\r\n  /**\r\n   * @ngdoc directive\r\n   * @name ngMessage\r\n   * @restrict AE\r\n   * @scope\r\n   *\r\n   * @description\r\n   * `ngMessage` is a directive with the purpose to show and hide a particular message.\r\n   * For `ngMessage` to operate, a parent `ngMessages` directive on a parent DOM element\r\n   * must be situated since it determines which messages are visible based on the state\r\n   * of the provided key/value map that `ngMessages` listens on.\r\n   *\r\n   * More information about using `ngMessage` can be found in the\r\n   * {@link module:ngMessages `ngMessages` module documentation}.\r\n   *\r\n   * @usage\r\n   * ```html\r\n   * <!-- using attribute directives -->\r\n   * <ANY ng-messages=\"expression\" role=\"alert\">\r\n   *   <ANY ng-message=\"stringValue\">...</ANY>\r\n   *   <ANY ng-message=\"stringValue1, stringValue2, ...\">...</ANY>\r\n   * </ANY>\r\n   *\r\n   * <!-- or by using element directives -->\r\n   * <ng-messages for=\"expression\" role=\"alert\">\r\n   *   <ng-message when=\"stringValue\">...</ng-message>\r\n   *   <ng-message when=\"stringValue1, stringValue2, ...\">...</ng-message>\r\n   * </ng-messages>\r\n   * ```\r\n   *\r\n   * @param {expression} ngMessage|when a string value corresponding to the message key.\r\n   */\r\n  .directive('ngMessage', ngMessageDirectiveFactory())\r\n\r\n\r\n  /**\r\n   * @ngdoc directive\r\n   * @name ngMessageExp\r\n   * @restrict AE\r\n   * @priority 1\r\n   * @scope\r\n   *\r\n   * @description\r\n   * `ngMessageExp` is the same as {@link directive:ngMessage `ngMessage`}, but instead of a static\r\n   * value, it accepts an expression to be evaluated for the message key.\r\n   *\r\n   * @usage\r\n   * ```html\r\n   * <!-- using attribute directives -->\r\n   * <ANY ng-messages=\"expression\">\r\n   *   <ANY ng-message-exp=\"expressionValue\">...</ANY>\r\n   * </ANY>\r\n   *\r\n   * <!-- or by using element directives -->\r\n   * <ng-messages for=\"expression\">\r\n   *   <ng-message when-exp=\"expressionValue\">...</ng-message>\r\n   * </ng-messages>\r\n   * ```\r\n   *\r\n   * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.\r\n   *\r\n   * @param {expression} ngMessageExp|whenExp an expression value corresponding to the message key.\r\n   */\r\n  .directive('ngMessageExp', ngMessageDirectiveFactory());\r\n\r\nfunction ngMessageDirectiveFactory() {\r\n  return ['$animate', function($animate) {\r\n    return {\r\n      restrict: 'AE',\r\n      transclude: 'element',\r\n      priority: 1, // must run before ngBind, otherwise the text is set on the comment\r\n      terminal: true,\r\n      require: '^^ngMessages',\r\n      link: function(scope, element, attrs, ngMessagesCtrl, $transclude) {\r\n        var commentNode = element[0];\r\n\r\n        var records;\r\n        var staticExp = attrs.ngMessage || attrs.when;\r\n        var dynamicExp = attrs.ngMessageExp || attrs.whenExp;\r\n        var assignRecords = function(items) {\r\n          records = items\r\n              ? (isArray(items)\r\n                  ? items\r\n                  : items.split(/[\\s,]+/))\r\n              : null;\r\n          ngMessagesCtrl.reRender();\r\n        };\r\n\r\n        if (dynamicExp) {\r\n          assignRecords(scope.$eval(dynamicExp));\r\n          scope.$watchCollection(dynamicExp, assignRecords);\r\n        } else {\r\n          assignRecords(staticExp);\r\n        }\r\n\r\n        var currentElement, messageCtrl;\r\n        ngMessagesCtrl.register(commentNode, messageCtrl = {\r\n          test: function(name) {\r\n            return contains(records, name);\r\n          },\r\n          attach: function() {\r\n            if (!currentElement) {\r\n              $transclude(function(elm, newScope) {\r\n                $animate.enter(elm, null, element);\r\n                currentElement = elm;\r\n\r\n                // Each time we attach this node to a message we get a new id that we can match\r\n                // when we are destroying the node later.\r\n                var $$attachId = currentElement.$$attachId = ngMessagesCtrl.getAttachId();\r\n\r\n                // in the event that the element or a parent element is destroyed\r\n                // by another structural directive then it's time\r\n                // to deregister the message from the controller\r\n                currentElement.on('$destroy', function() {\r\n                  if (currentElement && currentElement.$$attachId === $$attachId) {\r\n                    ngMessagesCtrl.deregister(commentNode);\r\n                    messageCtrl.detach();\r\n                  }\r\n                  newScope.$destroy();\r\n                });\r\n              });\r\n            }\r\n          },\r\n          detach: function() {\r\n            if (currentElement) {\r\n              var elm = currentElement;\r\n              currentElement = null;\r\n              $animate.leave(elm);\r\n            }\r\n          }\r\n        });\r\n      }\r\n    };\r\n  }];\r\n\r\n  function contains(collection, key) {\r\n    if (collection) {\r\n      return isArray(collection)\r\n          ? collection.indexOf(key) >= 0\r\n          : collection.hasOwnProperty(key);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n})(window, window.angular);\r\n"]}