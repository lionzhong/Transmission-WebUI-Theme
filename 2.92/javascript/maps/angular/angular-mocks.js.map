{"version":3,"sources":["angular/angular-mocks.js"],"names":["window","angular","jsonStringToDate","string","match","R_ISO8061_STR","date","Date","tzHour","tzMin","toInt","setUTCFullYear","setUTCHours","str","parseInt","padNumberInMock","num","digits","trim","neg","length","substr","createHttpBackendMock","$rootScope","$timeout","$delegate","$browser","createResponse","status","data","headers","statusText","isFunction","isNumber","$httpBackend","method","url","callback","timeout","withCredentials","responseType","eventHandlers","uploadEventHandlers","prettyPrint","isString","RegExp","toJson","wrapResponse","wrapped","handleResponse","response","params","xhr","$$respHeaders","copy","getAllResponseHeaders","handleTimeout","i","ii","responses","splice","undefined","then","MockXhr","expectation","expectations","wasExpected","$$events","upload","matchData","Error","matchHeaders","shift","push","definition","definitions","defer","responsesPush","passThrough","originalHttpBackend","parseRoute","ret","regexp","keys","replace","_","slash","key","option","optional","star","name","createShortMethods","prefix","forEach","assertArgDefined","arguments","isUndefined","bind","$$originalHttpBackend","when","MockHttpExpectation","chain","respond","whenRoute","pathObj","expect","expectRoute","flush","count","skip","digest","$digest","isDefined","part","verifyNoOutstandingExpectation","join","verifyNoOutstandingRequest","resetExpectations","args","index","getUrlParams","u","slice","indexOf","split","sort","compareUrl","this","m","d","h","matchUrl","test","equals","fromJson","toString","pathParams","keyObj","exec","len","val","parseQuery","key_value","obj","queryStr","substring","keyValue","tryDecodeURIComponent","hasOwnProperty","call","isArray","value","decodeURIComponent","e","extend","$$lastInstance","open","async","$$method","$$url","$$async","$$reqHeaders","send","$$data","setRequestHeader","getResponseHeader","header","lowercase","headerVal","headerName","lines","abort","noop","addEventListener","listener","createControllerDecorator","compileProvider","mock","$ControllerDecorator","expression","locals","later","ident","preAssignBindingsEnabled","instantiate","instance","$BrowserProvider","$get","$Browser","self","isMock","$$lastUrl","pollFns","outstandingRequestCount","outstandingRequestCallbacks","$$incOutstandingRequestCount","$$completeOutstandingRequest","fn","pop","notifyWhenNoOutstandingRequests","onUrlChange","$$state","$$lastState","$$applicationDestroyed","$$checkUrlChange","deferredFns","deferredNextId","delay","time","now","id","a","b","cancel","deferId","fnIndex","nextTime","$$baseHref","baseHref","prototype","poll","pollFn","state","$ExceptionHandlerProvider","handler","mode","errors","$LogProvider","concat","array1","array2","Array","debug","debugEnabled","flag","$log","log","logs","warn","info","error","reset","assertEmpty","logLevel","logItem","String","stack","unshift","$IntervalProvider","$q","$$q","repeatFns","nextRepeatId","$interval","invokeApply","tick","deferred","notify","iteration","resolve","promise","$$intervalId","skipApply","$apply","hasParams","apply","reject","millis","task","TzDate","offset","timestamp","tsStr","origDate","getTime","isNaN","message","localOffset","getTimezoneOffset","offsetDiff","toLocaleDateString","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","getDay","toISOString","unimplementedMethods","methodName","animate","module","config","$provide","factory","reflowFn","totalReflows","queue","queueFn","decorator","runners","animateJsConstructor","animator","$closeAndFlush","runner","end","animateCssConstructor","element","options","$$rAF","$animateCss","$$animateJs","$$forceReflow","$$animateAsyncRun","on","off","pin","reflows","enabled","closeAndFlush","hideErrors","doNextRun","somethingFlushed","event","dump","object","serialize","out","isElement","append","clone","html","o","isObject","$eval","serializeScope","scope","$id","Object","child","$$childHead","$$nextSibling","$httpBackendDecorator","$TimeoutDecorator","formatPendingTasksAsString","tasks","result","verifyNoPendingTasks","$RAFDecorator","rafFn","supported","originalRootElement","$RootElementProvider","$injector","$ComponentControllerProvider","$compileProvider","$controller","componentName","bindings","directives","get","candidateDirectives","filter","directiveInfo","controller","controllerAs","restrict","$scope","$new","provider","$exceptionHandler","$rootElement","$componentController","$RootScopeDecorator","e2e","countChildScopes","currentScope","pendingChildHeads","countWatchers","$$watchers","$rootScopePrototype","getPrototypeOf","$countChildScopes","$countWatchers","jasmineOrMocha","InjectorState","shared","sharedError","cleanupAfterEach","currentSpec","injectorState","annotatedFunctions","wasInjectorCreated","$$annotate","injector","$inject","workFn","modules","$modules","moduleFns","$providerInjector","invoke","$$beforeAllHook","before","beforeAll","$$afterAllHook","after","afterAll","$$currentSpec","to","sharedInjector","initialized","$$cleanup","$$beforeEach","k","$$afterEach","rootNode","cleanUpNodes","cleanData","$destroy","fragments","callbacks","$$counter","beforeEach","setup","afterEach","teardown","ErrorAddingDeclarationLocationStack","errorForStack","line","sourceId","stackArray","inject","WorkFn","strictDi","$injectorStrict","moduleFn","blockFns","annotate","jasmine","mocha","supportsTouchEvents","_cached","document","createTouch","createTouchList","createEvent","createTouchEvent","eventType","x","y","evnt","Event","touch","touches","supportsEventBubblingInDetachedTree","doc","parent","createElement","cloneNode","appendChild","initEvent","dispatchEvent","triggerForPath","stop","_stopPropagation","stopPropagation","patchEventTargetForBubbling","parentNode","target","_target","defineProperty","isAttachedToDocument","browserTrigger","eventData","pressed","nodeName","relatedTarget","inputType","type","toLowerCase","text","textarea","hidden","password","button","submit","image","checkbox","radio","select-one","select-multiple","_default_","WebKitTransitionEvent","TransitionEvent","initTransitionEvent","elapsedTime","WebKitAnimationEvent","AnimationEvent","initAnimationEvent","bubbles","cancelable","view","ctrlKey","altKey","shiftKey","metaKey","keyCode","charCode","which","initMouseEvent","$manualTimeStamp","timeStamp","finalProcessDefault","originalPreventDefault","preventDefault","appWindow","ownerDocument","defaultView","fakeProcessDefault"],"mappings":"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","file":"../../angular/angular-mocks.js","sourcesContent":["/**\r\n * @license AngularJS v1.6.2\r\n * (c) 2010-2017 Google, Inc. http://angularjs.org\r\n * License: MIT\r\n */\r\n(function(window, angular) {\r\n\r\n'use strict';\r\n\r\n/**\r\n * @ngdoc object\r\n * @name angular.mock\r\n * @description\r\n *\r\n * Namespace from 'angular-mocks.js' which contains testing related code.\r\n *\r\n */\r\nangular.mock = {};\r\n\r\n/**\r\n * ! This is a private undocumented service !\r\n *\r\n * @name $browser\r\n *\r\n * @description\r\n * This service is a mock implementation of {@link ng.$browser}. It provides fake\r\n * implementation for commonly used browser apis that are hard to test, e.g. setTimeout, xhr,\r\n * cookies, etc.\r\n *\r\n * The api of this service is the same as that of the real {@link ng.$browser $browser}, except\r\n * that there are several helper methods available which can be used in tests.\r\n */\r\nangular.mock.$BrowserProvider = function() {\r\n  this.$get = function() {\r\n    return new angular.mock.$Browser();\r\n  };\r\n};\r\n\r\nangular.mock.$Browser = function() {\r\n  var self = this;\r\n\r\n  this.isMock = true;\r\n  self.$$url = 'http://server/';\r\n  self.$$lastUrl = self.$$url; // used by url polling fn\r\n  self.pollFns = [];\r\n\r\n  // Testability API\r\n\r\n  var outstandingRequestCount = 0;\r\n  var outstandingRequestCallbacks = [];\r\n  self.$$incOutstandingRequestCount = function() { outstandingRequestCount++; };\r\n  self.$$completeOutstandingRequest = function(fn) {\r\n    try {\r\n      fn();\r\n    } finally {\r\n      outstandingRequestCount--;\r\n      if (!outstandingRequestCount) {\r\n        while (outstandingRequestCallbacks.length) {\r\n          outstandingRequestCallbacks.pop()();\r\n        }\r\n      }\r\n    }\r\n  };\r\n  self.notifyWhenNoOutstandingRequests = function(callback) {\r\n    if (outstandingRequestCount) {\r\n      outstandingRequestCallbacks.push(callback);\r\n    } else {\r\n      callback();\r\n    }\r\n  };\r\n\r\n  // register url polling fn\r\n\r\n  self.onUrlChange = function(listener) {\r\n    self.pollFns.push(\r\n      function() {\r\n        if (self.$$lastUrl !== self.$$url || self.$$state !== self.$$lastState) {\r\n          self.$$lastUrl = self.$$url;\r\n          self.$$lastState = self.$$state;\r\n          listener(self.$$url, self.$$state);\r\n        }\r\n      }\r\n    );\r\n\r\n    return listener;\r\n  };\r\n\r\n  self.$$applicationDestroyed = angular.noop;\r\n  self.$$checkUrlChange = angular.noop;\r\n\r\n  self.deferredFns = [];\r\n  self.deferredNextId = 0;\r\n\r\n  self.defer = function(fn, delay) {\r\n    // Note that we do not use `$$incOutstandingRequestCount` or `$$completeOutstandingRequest`\r\n    // in this mock implementation.\r\n    delay = delay || 0;\r\n    self.deferredFns.push({time:(self.defer.now + delay), fn:fn, id: self.deferredNextId});\r\n    self.deferredFns.sort(function(a, b) { return a.time - b.time;});\r\n    return self.deferredNextId++;\r\n  };\r\n\r\n\r\n  /**\r\n   * @name $browser#defer.now\r\n   *\r\n   * @description\r\n   * Current milliseconds mock time.\r\n   */\r\n  self.defer.now = 0;\r\n\r\n\r\n  self.defer.cancel = function(deferId) {\r\n    var fnIndex;\r\n\r\n    angular.forEach(self.deferredFns, function(fn, index) {\r\n      if (fn.id === deferId) fnIndex = index;\r\n    });\r\n\r\n    if (angular.isDefined(fnIndex)) {\r\n      self.deferredFns.splice(fnIndex, 1);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n\r\n  /**\r\n   * @name $browser#defer.flush\r\n   *\r\n   * @description\r\n   * Flushes all pending requests and executes the defer callbacks.\r\n   *\r\n   * @param {number=} number of milliseconds to flush. See {@link #defer.now}\r\n   */\r\n  self.defer.flush = function(delay) {\r\n    var nextTime;\r\n\r\n    if (angular.isDefined(delay)) {\r\n      // A delay was passed so compute the next time\r\n      nextTime = self.defer.now + delay;\r\n    } else {\r\n      if (self.deferredFns.length) {\r\n        // No delay was passed so set the next time so that it clears the deferred queue\r\n        nextTime = self.deferredFns[self.deferredFns.length - 1].time;\r\n      } else {\r\n        // No delay passed, but there are no deferred tasks so flush - indicates an error!\r\n        throw new Error('No deferred tasks to be flushed');\r\n      }\r\n    }\r\n\r\n    while (self.deferredFns.length && self.deferredFns[0].time <= nextTime) {\r\n      // Increment the time and call the next deferred function\r\n      self.defer.now = self.deferredFns[0].time;\r\n      self.deferredFns.shift().fn();\r\n    }\r\n\r\n    // Ensure that the current time is correct\r\n    self.defer.now = nextTime;\r\n  };\r\n\r\n  self.$$baseHref = '/';\r\n  self.baseHref = function() {\r\n    return this.$$baseHref;\r\n  };\r\n};\r\nangular.mock.$Browser.prototype = {\r\n\r\n  /**\r\n   * @name $browser#poll\r\n   *\r\n   * @description\r\n   * run all fns in pollFns\r\n   */\r\n  poll: function poll() {\r\n    angular.forEach(this.pollFns, function(pollFn) {\r\n      pollFn();\r\n    });\r\n  },\r\n\r\n  url: function(url, replace, state) {\r\n    if (angular.isUndefined(state)) {\r\n      state = null;\r\n    }\r\n    if (url) {\r\n      this.$$url = url;\r\n      // Native pushState serializes & copies the object; simulate it.\r\n      this.$$state = angular.copy(state);\r\n      return this;\r\n    }\r\n\r\n    return this.$$url;\r\n  },\r\n\r\n  state: function() {\r\n    return this.$$state;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @ngdoc provider\r\n * @name $exceptionHandlerProvider\r\n *\r\n * @description\r\n * Configures the mock implementation of {@link ng.$exceptionHandler} to rethrow or to log errors\r\n * passed to the `$exceptionHandler`.\r\n */\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $exceptionHandler\r\n *\r\n * @description\r\n * Mock implementation of {@link ng.$exceptionHandler} that rethrows or logs errors passed\r\n * to it. See {@link ngMock.$exceptionHandlerProvider $exceptionHandlerProvider} for configuration\r\n * information.\r\n *\r\n *\r\n * ```js\r\n *   describe('$exceptionHandlerProvider', function() {\r\n *\r\n *     it('should capture log messages and exceptions', function() {\r\n *\r\n *       module(function($exceptionHandlerProvider) {\r\n *         $exceptionHandlerProvider.mode('log');\r\n *       });\r\n *\r\n *       inject(function($log, $exceptionHandler, $timeout) {\r\n *         $timeout(function() { $log.log(1); });\r\n *         $timeout(function() { $log.log(2); throw 'banana peel'; });\r\n *         $timeout(function() { $log.log(3); });\r\n *         expect($exceptionHandler.errors).toEqual([]);\r\n *         expect($log.assertEmpty());\r\n *         $timeout.flush();\r\n *         expect($exceptionHandler.errors).toEqual(['banana peel']);\r\n *         expect($log.log.logs).toEqual([[1], [2], [3]]);\r\n *       });\r\n *     });\r\n *   });\r\n * ```\r\n */\r\n\r\nangular.mock.$ExceptionHandlerProvider = function() {\r\n  var handler;\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $exceptionHandlerProvider#mode\r\n   *\r\n   * @description\r\n   * Sets the logging mode.\r\n   *\r\n   * @param {string} mode Mode of operation, defaults to `rethrow`.\r\n   *\r\n   *   - `log`: Sometimes it is desirable to test that an error is thrown, for this case the `log`\r\n   *     mode stores an array of errors in `$exceptionHandler.errors`, to allow later assertion of\r\n   *     them. See {@link ngMock.$log#assertEmpty assertEmpty()} and\r\n   *     {@link ngMock.$log#reset reset()}.\r\n   *   - `rethrow`: If any errors are passed to the handler in tests, it typically means that there\r\n   *     is a bug in the application or test, so this mock will make these tests fail. For any\r\n   *     implementations that expect exceptions to be thrown, the `rethrow` mode will also maintain\r\n   *     a log of thrown errors in `$exceptionHandler.errors`.\r\n   */\r\n  this.mode = function(mode) {\r\n\r\n    switch (mode) {\r\n      case 'log':\r\n      case 'rethrow':\r\n        var errors = [];\r\n        handler = function(e) {\r\n          if (arguments.length === 1) {\r\n            errors.push(e);\r\n          } else {\r\n            errors.push([].slice.call(arguments, 0));\r\n          }\r\n          if (mode === 'rethrow') {\r\n            throw e;\r\n          }\r\n        };\r\n        handler.errors = errors;\r\n        break;\r\n      default:\r\n        throw new Error('Unknown mode \\'' + mode + '\\', only \\'log\\'/\\'rethrow\\' modes are allowed!');\r\n    }\r\n  };\r\n\r\n  this.$get = function() {\r\n    return handler;\r\n  };\r\n\r\n  this.mode('rethrow');\r\n};\r\n\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $log\r\n *\r\n * @description\r\n * Mock implementation of {@link ng.$log} that gathers all logged messages in arrays\r\n * (one array per logging level). These arrays are exposed as `logs` property of each of the\r\n * level-specific log function, e.g. for level `error` the array is exposed as `$log.error.logs`.\r\n *\r\n */\r\nangular.mock.$LogProvider = function() {\r\n  var debug = true;\r\n\r\n  function concat(array1, array2, index) {\r\n    return array1.concat(Array.prototype.slice.call(array2, index));\r\n  }\r\n\r\n  this.debugEnabled = function(flag) {\r\n    if (angular.isDefined(flag)) {\r\n      debug = flag;\r\n      return this;\r\n    } else {\r\n      return debug;\r\n    }\r\n  };\r\n\r\n  this.$get = function() {\r\n    var $log = {\r\n      log: function() { $log.log.logs.push(concat([], arguments, 0)); },\r\n      warn: function() { $log.warn.logs.push(concat([], arguments, 0)); },\r\n      info: function() { $log.info.logs.push(concat([], arguments, 0)); },\r\n      error: function() { $log.error.logs.push(concat([], arguments, 0)); },\r\n      debug: function() {\r\n        if (debug) {\r\n          $log.debug.logs.push(concat([], arguments, 0));\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name $log#reset\r\n     *\r\n     * @description\r\n     * Reset all of the logging arrays to empty.\r\n     */\r\n    $log.reset = function() {\r\n      /**\r\n       * @ngdoc property\r\n       * @name $log#log.logs\r\n       *\r\n       * @description\r\n       * Array of messages logged using {@link ng.$log#log `log()`}.\r\n       *\r\n       * @example\r\n       * ```js\r\n       * $log.log('Some Log');\r\n       * var first = $log.log.logs.unshift();\r\n       * ```\r\n       */\r\n      $log.log.logs = [];\r\n      /**\r\n       * @ngdoc property\r\n       * @name $log#info.logs\r\n       *\r\n       * @description\r\n       * Array of messages logged using {@link ng.$log#info `info()`}.\r\n       *\r\n       * @example\r\n       * ```js\r\n       * $log.info('Some Info');\r\n       * var first = $log.info.logs.unshift();\r\n       * ```\r\n       */\r\n      $log.info.logs = [];\r\n      /**\r\n       * @ngdoc property\r\n       * @name $log#warn.logs\r\n       *\r\n       * @description\r\n       * Array of messages logged using {@link ng.$log#warn `warn()`}.\r\n       *\r\n       * @example\r\n       * ```js\r\n       * $log.warn('Some Warning');\r\n       * var first = $log.warn.logs.unshift();\r\n       * ```\r\n       */\r\n      $log.warn.logs = [];\r\n      /**\r\n       * @ngdoc property\r\n       * @name $log#error.logs\r\n       *\r\n       * @description\r\n       * Array of messages logged using {@link ng.$log#error `error()`}.\r\n       *\r\n       * @example\r\n       * ```js\r\n       * $log.error('Some Error');\r\n       * var first = $log.error.logs.unshift();\r\n       * ```\r\n       */\r\n      $log.error.logs = [];\r\n        /**\r\n       * @ngdoc property\r\n       * @name $log#debug.logs\r\n       *\r\n       * @description\r\n       * Array of messages logged using {@link ng.$log#debug `debug()`}.\r\n       *\r\n       * @example\r\n       * ```js\r\n       * $log.debug('Some Error');\r\n       * var first = $log.debug.logs.unshift();\r\n       * ```\r\n       */\r\n      $log.debug.logs = [];\r\n    };\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name $log#assertEmpty\r\n     *\r\n     * @description\r\n     * Assert that all of the logging methods have no logged messages. If any messages are present,\r\n     * an exception is thrown.\r\n     */\r\n    $log.assertEmpty = function() {\r\n      var errors = [];\r\n      angular.forEach(['error', 'warn', 'info', 'log', 'debug'], function(logLevel) {\r\n        angular.forEach($log[logLevel].logs, function(log) {\r\n          angular.forEach(log, function(logItem) {\r\n            errors.push('MOCK $log (' + logLevel + '): ' + String(logItem) + '\\n' +\r\n                        (logItem.stack || ''));\r\n          });\r\n        });\r\n      });\r\n      if (errors.length) {\r\n        errors.unshift('Expected $log to be empty! Either a message was logged unexpectedly, or ' +\r\n          'an expected log message was not checked and removed:');\r\n        errors.push('');\r\n        throw new Error(errors.join('\\n---------\\n'));\r\n      }\r\n    };\r\n\r\n    $log.reset();\r\n    return $log;\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $interval\r\n *\r\n * @description\r\n * Mock implementation of the $interval service.\r\n *\r\n * Use {@link ngMock.$interval#flush `$interval.flush(millis)`} to\r\n * move forward by `millis` milliseconds and trigger any functions scheduled to run in that\r\n * time.\r\n *\r\n * @param {function()} fn A function that should be called repeatedly.\r\n * @param {number} delay Number of milliseconds between each function call.\r\n * @param {number=} [count=0] Number of times to repeat. If not set, or 0, will repeat\r\n *   indefinitely.\r\n * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise\r\n *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.\r\n * @param {...*=} Pass additional parameters to the executed function.\r\n * @returns {promise} A promise which will be notified on each iteration.\r\n */\r\nangular.mock.$IntervalProvider = function() {\r\n  this.$get = ['$browser', '$rootScope', '$q', '$$q',\r\n       function($browser,   $rootScope,   $q,   $$q) {\r\n    var repeatFns = [],\r\n        nextRepeatId = 0,\r\n        now = 0;\r\n\r\n    var $interval = function(fn, delay, count, invokeApply) {\r\n      var hasParams = arguments.length > 4,\r\n          args = hasParams ? Array.prototype.slice.call(arguments, 4) : [],\r\n          iteration = 0,\r\n          skipApply = (angular.isDefined(invokeApply) && !invokeApply),\r\n          deferred = (skipApply ? $$q : $q).defer(),\r\n          promise = deferred.promise;\r\n\r\n      count = (angular.isDefined(count)) ? count : 0;\r\n      promise.then(null, function() {}, (!hasParams) ? fn : function() {\r\n        fn.apply(null, args);\r\n      });\r\n\r\n      promise.$$intervalId = nextRepeatId;\r\n\r\n      function tick() {\r\n        deferred.notify(iteration++);\r\n\r\n        if (count > 0 && iteration >= count) {\r\n          var fnIndex;\r\n          deferred.resolve(iteration);\r\n\r\n          angular.forEach(repeatFns, function(fn, index) {\r\n            if (fn.id === promise.$$intervalId) fnIndex = index;\r\n          });\r\n\r\n          if (angular.isDefined(fnIndex)) {\r\n            repeatFns.splice(fnIndex, 1);\r\n          }\r\n        }\r\n\r\n        if (skipApply) {\r\n          $browser.defer.flush();\r\n        } else {\r\n          $rootScope.$apply();\r\n        }\r\n      }\r\n\r\n      repeatFns.push({\r\n        nextTime:(now + delay),\r\n        delay: delay,\r\n        fn: tick,\r\n        id: nextRepeatId,\r\n        deferred: deferred\r\n      });\r\n      repeatFns.sort(function(a, b) { return a.nextTime - b.nextTime;});\r\n\r\n      nextRepeatId++;\r\n      return promise;\r\n    };\r\n    /**\r\n     * @ngdoc method\r\n     * @name $interval#cancel\r\n     *\r\n     * @description\r\n     * Cancels a task associated with the `promise`.\r\n     *\r\n     * @param {promise} promise A promise from calling the `$interval` function.\r\n     * @returns {boolean} Returns `true` if the task was successfully cancelled.\r\n     */\r\n    $interval.cancel = function(promise) {\r\n      if (!promise) return false;\r\n      var fnIndex;\r\n\r\n      angular.forEach(repeatFns, function(fn, index) {\r\n        if (fn.id === promise.$$intervalId) fnIndex = index;\r\n      });\r\n\r\n      if (angular.isDefined(fnIndex)) {\r\n        repeatFns[fnIndex].deferred.promise.then(undefined, function() {});\r\n        repeatFns[fnIndex].deferred.reject('canceled');\r\n        repeatFns.splice(fnIndex, 1);\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name $interval#flush\r\n     * @description\r\n     *\r\n     * Runs interval tasks scheduled to be run in the next `millis` milliseconds.\r\n     *\r\n     * @param {number=} millis maximum timeout amount to flush up until.\r\n     *\r\n     * @return {number} The amount of time moved forward.\r\n     */\r\n    $interval.flush = function(millis) {\r\n      now += millis;\r\n      while (repeatFns.length && repeatFns[0].nextTime <= now) {\r\n        var task = repeatFns[0];\r\n        task.fn();\r\n        task.nextTime += task.delay;\r\n        repeatFns.sort(function(a, b) { return a.nextTime - b.nextTime;});\r\n      }\r\n      return millis;\r\n    };\r\n\r\n    return $interval;\r\n  }];\r\n};\r\n\r\n\r\nfunction jsonStringToDate(string) {\r\n  // The R_ISO8061_STR regex is never going to fit into the 100 char limit!\r\n  // eslit-disable-next-line max-len\r\n  var R_ISO8061_STR = /^(-?\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d{3}))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d)))?$/;\r\n\r\n  var match;\r\n  if ((match = string.match(R_ISO8061_STR))) {\r\n    var date = new Date(0),\r\n        tzHour = 0,\r\n        tzMin  = 0;\r\n    if (match[9]) {\r\n      tzHour = toInt(match[9] + match[10]);\r\n      tzMin = toInt(match[9] + match[11]);\r\n    }\r\n    date.setUTCFullYear(toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));\r\n    date.setUTCHours(toInt(match[4] || 0) - tzHour,\r\n                     toInt(match[5] || 0) - tzMin,\r\n                     toInt(match[6] || 0),\r\n                     toInt(match[7] || 0));\r\n    return date;\r\n  }\r\n  return string;\r\n}\r\n\r\nfunction toInt(str) {\r\n  return parseInt(str, 10);\r\n}\r\n\r\nfunction padNumberInMock(num, digits, trim) {\r\n  var neg = '';\r\n  if (num < 0) {\r\n    neg =  '-';\r\n    num = -num;\r\n  }\r\n  num = '' + num;\r\n  while (num.length < digits) num = '0' + num;\r\n  if (trim) {\r\n    num = num.substr(num.length - digits);\r\n  }\r\n  return neg + num;\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc type\r\n * @name angular.mock.TzDate\r\n * @description\r\n *\r\n * *NOTE*: this is not an injectable instance, just a globally available mock class of `Date`.\r\n *\r\n * Mock of the Date type which has its timezone specified via constructor arg.\r\n *\r\n * The main purpose is to create Date-like instances with timezone fixed to the specified timezone\r\n * offset, so that we can test code that depends on local timezone settings without dependency on\r\n * the time zone settings of the machine where the code is running.\r\n *\r\n * @param {number} offset Offset of the *desired* timezone in hours (fractions will be honored)\r\n * @param {(number|string)} timestamp Timestamp representing the desired time in *UTC*\r\n *\r\n * @example\r\n * !!!! WARNING !!!!!\r\n * This is not a complete Date object so only methods that were implemented can be called safely.\r\n * To make matters worse, TzDate instances inherit stuff from Date via a prototype.\r\n *\r\n * We do our best to intercept calls to \"unimplemented\" methods, but since the list of methods is\r\n * incomplete we might be missing some non-standard methods. This can result in errors like:\r\n * \"Date.prototype.foo called on incompatible Object\".\r\n *\r\n * ```js\r\n * var newYearInBratislava = new TzDate(-1, '2009-12-31T23:00:00Z');\r\n * newYearInBratislava.getTimezoneOffset() => -60;\r\n * newYearInBratislava.getFullYear() => 2010;\r\n * newYearInBratislava.getMonth() => 0;\r\n * newYearInBratislava.getDate() => 1;\r\n * newYearInBratislava.getHours() => 0;\r\n * newYearInBratislava.getMinutes() => 0;\r\n * newYearInBratislava.getSeconds() => 0;\r\n * ```\r\n *\r\n */\r\nangular.mock.TzDate = function(offset, timestamp) {\r\n  var self = new Date(0);\r\n  if (angular.isString(timestamp)) {\r\n    var tsStr = timestamp;\r\n\r\n    self.origDate = jsonStringToDate(timestamp);\r\n\r\n    timestamp = self.origDate.getTime();\r\n    if (isNaN(timestamp)) {\r\n      // eslint-disable-next-line no-throw-literal\r\n      throw {\r\n        name: 'Illegal Argument',\r\n        message: 'Arg \\'' + tsStr + '\\' passed into TzDate constructor is not a valid date string'\r\n      };\r\n    }\r\n  } else {\r\n    self.origDate = new Date(timestamp);\r\n  }\r\n\r\n  var localOffset = new Date(timestamp).getTimezoneOffset();\r\n  self.offsetDiff = localOffset * 60 * 1000 - offset * 1000 * 60 * 60;\r\n  self.date = new Date(timestamp + self.offsetDiff);\r\n\r\n  self.getTime = function() {\r\n    return self.date.getTime() - self.offsetDiff;\r\n  };\r\n\r\n  self.toLocaleDateString = function() {\r\n    return self.date.toLocaleDateString();\r\n  };\r\n\r\n  self.getFullYear = function() {\r\n    return self.date.getFullYear();\r\n  };\r\n\r\n  self.getMonth = function() {\r\n    return self.date.getMonth();\r\n  };\r\n\r\n  self.getDate = function() {\r\n    return self.date.getDate();\r\n  };\r\n\r\n  self.getHours = function() {\r\n    return self.date.getHours();\r\n  };\r\n\r\n  self.getMinutes = function() {\r\n    return self.date.getMinutes();\r\n  };\r\n\r\n  self.getSeconds = function() {\r\n    return self.date.getSeconds();\r\n  };\r\n\r\n  self.getMilliseconds = function() {\r\n    return self.date.getMilliseconds();\r\n  };\r\n\r\n  self.getTimezoneOffset = function() {\r\n    return offset * 60;\r\n  };\r\n\r\n  self.getUTCFullYear = function() {\r\n    return self.origDate.getUTCFullYear();\r\n  };\r\n\r\n  self.getUTCMonth = function() {\r\n    return self.origDate.getUTCMonth();\r\n  };\r\n\r\n  self.getUTCDate = function() {\r\n    return self.origDate.getUTCDate();\r\n  };\r\n\r\n  self.getUTCHours = function() {\r\n    return self.origDate.getUTCHours();\r\n  };\r\n\r\n  self.getUTCMinutes = function() {\r\n    return self.origDate.getUTCMinutes();\r\n  };\r\n\r\n  self.getUTCSeconds = function() {\r\n    return self.origDate.getUTCSeconds();\r\n  };\r\n\r\n  self.getUTCMilliseconds = function() {\r\n    return self.origDate.getUTCMilliseconds();\r\n  };\r\n\r\n  self.getDay = function() {\r\n    return self.date.getDay();\r\n  };\r\n\r\n  // provide this method only on browsers that already have it\r\n  if (self.toISOString) {\r\n    self.toISOString = function() {\r\n      return padNumberInMock(self.origDate.getUTCFullYear(), 4) + '-' +\r\n            padNumberInMock(self.origDate.getUTCMonth() + 1, 2) + '-' +\r\n            padNumberInMock(self.origDate.getUTCDate(), 2) + 'T' +\r\n            padNumberInMock(self.origDate.getUTCHours(), 2) + ':' +\r\n            padNumberInMock(self.origDate.getUTCMinutes(), 2) + ':' +\r\n            padNumberInMock(self.origDate.getUTCSeconds(), 2) + '.' +\r\n            padNumberInMock(self.origDate.getUTCMilliseconds(), 3) + 'Z';\r\n    };\r\n  }\r\n\r\n  //hide all methods not implemented in this mock that the Date prototype exposes\r\n  var unimplementedMethods = ['getUTCDay',\r\n      'getYear', 'setDate', 'setFullYear', 'setHours', 'setMilliseconds',\r\n      'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate', 'setUTCFullYear',\r\n      'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds',\r\n      'setYear', 'toDateString', 'toGMTString', 'toJSON', 'toLocaleFormat', 'toLocaleString',\r\n      'toLocaleTimeString', 'toSource', 'toString', 'toTimeString', 'toUTCString', 'valueOf'];\r\n\r\n  angular.forEach(unimplementedMethods, function(methodName) {\r\n    self[methodName] = function() {\r\n      throw new Error('Method \\'' + methodName + '\\' is not implemented in the TzDate mock');\r\n    };\r\n  });\r\n\r\n  return self;\r\n};\r\n\r\n//make \"tzDateInstance instanceof Date\" return true\r\nangular.mock.TzDate.prototype = Date.prototype;\r\n\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $animate\r\n *\r\n * @description\r\n * Mock implementation of the {@link ng.$animate `$animate`} service. Exposes two additional methods\r\n * for testing animations.\r\n *\r\n * You need to require the `ngAnimateMock` module in your test suite for instance `beforeEach(module('ngAnimateMock'))`\r\n */\r\nangular.mock.animate = angular.module('ngAnimateMock', ['ng'])\r\n\r\n  .config(['$provide', function($provide) {\r\n\r\n    $provide.factory('$$forceReflow', function() {\r\n      function reflowFn() {\r\n        reflowFn.totalReflows++;\r\n      }\r\n      reflowFn.totalReflows = 0;\r\n      return reflowFn;\r\n    });\r\n\r\n    $provide.factory('$$animateAsyncRun', function() {\r\n      var queue = [];\r\n      var queueFn = function() {\r\n        return function(fn) {\r\n          queue.push(fn);\r\n        };\r\n      };\r\n      queueFn.flush = function() {\r\n        if (queue.length === 0) return false;\r\n\r\n        for (var i = 0; i < queue.length; i++) {\r\n          queue[i]();\r\n        }\r\n        queue = [];\r\n\r\n        return true;\r\n      };\r\n      return queueFn;\r\n    });\r\n\r\n    $provide.decorator('$$animateJs', ['$delegate', function($delegate) {\r\n      var runners = [];\r\n\r\n      var animateJsConstructor = function() {\r\n        var animator = $delegate.apply($delegate, arguments);\r\n        // If no javascript animation is found, animator is undefined\r\n        if (animator) {\r\n          runners.push(animator);\r\n        }\r\n        return animator;\r\n      };\r\n\r\n      animateJsConstructor.$closeAndFlush = function() {\r\n        runners.forEach(function(runner) {\r\n          runner.end();\r\n        });\r\n        runners = [];\r\n      };\r\n\r\n      return animateJsConstructor;\r\n    }]);\r\n\r\n    $provide.decorator('$animateCss', ['$delegate', function($delegate) {\r\n      var runners = [];\r\n\r\n      var animateCssConstructor = function(element, options) {\r\n        var animator = $delegate(element, options);\r\n        runners.push(animator);\r\n        return animator;\r\n      };\r\n\r\n      animateCssConstructor.$closeAndFlush = function() {\r\n        runners.forEach(function(runner) {\r\n          runner.end();\r\n        });\r\n        runners = [];\r\n      };\r\n\r\n      return animateCssConstructor;\r\n    }]);\r\n\r\n    $provide.decorator('$animate', ['$delegate', '$timeout', '$browser', '$$rAF', '$animateCss', '$$animateJs',\r\n                                    '$$forceReflow', '$$animateAsyncRun', '$rootScope',\r\n                            function($delegate,   $timeout,   $browser,   $$rAF,   $animateCss,   $$animateJs,\r\n                                     $$forceReflow,   $$animateAsyncRun,  $rootScope) {\r\n      var animate = {\r\n        queue: [],\r\n        cancel: $delegate.cancel,\r\n        on: $delegate.on,\r\n        off: $delegate.off,\r\n        pin: $delegate.pin,\r\n        get reflows() {\r\n          return $$forceReflow.totalReflows;\r\n        },\r\n        enabled: $delegate.enabled,\r\n        /**\r\n         * @ngdoc method\r\n         * @name $animate#closeAndFlush\r\n         * @description\r\n         *\r\n         * This method will close all pending animations (both {@link ngAnimate#javascript-based-animations Javascript}\r\n         * and {@link ngAnimate.$animateCss CSS}) and it will also flush any remaining animation frames and/or callbacks.\r\n         */\r\n        closeAndFlush: function() {\r\n          // we allow the flush command to swallow the errors\r\n          // because depending on whether CSS or JS animations are\r\n          // used, there may not be a RAF flush. The primary flush\r\n          // at the end of this function must throw an exception\r\n          // because it will track if there were pending animations\r\n          this.flush(true);\r\n          $animateCss.$closeAndFlush();\r\n          $$animateJs.$closeAndFlush();\r\n          this.flush();\r\n        },\r\n        /**\r\n         * @ngdoc method\r\n         * @name $animate#flush\r\n         * @description\r\n         *\r\n         * This method is used to flush the pending callbacks and animation frames to either start\r\n         * an animation or conclude an animation. Note that this will not actually close an\r\n         * actively running animation (see {@link ngMock.$animate#closeAndFlush `closeAndFlush()`} for that).\r\n         */\r\n        flush: function(hideErrors) {\r\n          $rootScope.$digest();\r\n\r\n          var doNextRun, somethingFlushed = false;\r\n          do {\r\n            doNextRun = false;\r\n\r\n            if ($$rAF.queue.length) {\r\n              $$rAF.flush();\r\n              doNextRun = somethingFlushed = true;\r\n            }\r\n\r\n            if ($$animateAsyncRun.flush()) {\r\n              doNextRun = somethingFlushed = true;\r\n            }\r\n          } while (doNextRun);\r\n\r\n          if (!somethingFlushed && !hideErrors) {\r\n            throw new Error('No pending animations ready to be closed or flushed');\r\n          }\r\n\r\n          $rootScope.$digest();\r\n        }\r\n      };\r\n\r\n      angular.forEach(\r\n        ['animate','enter','leave','move','addClass','removeClass','setClass'], function(method) {\r\n        animate[method] = function() {\r\n          animate.queue.push({\r\n            event: method,\r\n            element: arguments[0],\r\n            options: arguments[arguments.length - 1],\r\n            args: arguments\r\n          });\r\n          return $delegate[method].apply($delegate, arguments);\r\n        };\r\n      });\r\n\r\n      return animate;\r\n    }]);\r\n\r\n  }]);\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.mock.dump\r\n * @description\r\n *\r\n * *NOTE*: This is not an injectable instance, just a globally available function.\r\n *\r\n * Method for serializing common angular objects (scope, elements, etc..) into strings.\r\n * It is useful for logging objects to the console when debugging.\r\n *\r\n * @param {*} object - any object to turn into string.\r\n * @return {string} a serialized string of the argument\r\n */\r\nangular.mock.dump = function(object) {\r\n  return serialize(object);\r\n\r\n  function serialize(object) {\r\n    var out;\r\n\r\n    if (angular.isElement(object)) {\r\n      object = angular.element(object);\r\n      out = angular.element('<div></div>');\r\n      angular.forEach(object, function(element) {\r\n        out.append(angular.element(element).clone());\r\n      });\r\n      out = out.html();\r\n    } else if (angular.isArray(object)) {\r\n      out = [];\r\n      angular.forEach(object, function(o) {\r\n        out.push(serialize(o));\r\n      });\r\n      out = '[ ' + out.join(', ') + ' ]';\r\n    } else if (angular.isObject(object)) {\r\n      if (angular.isFunction(object.$eval) && angular.isFunction(object.$apply)) {\r\n        out = serializeScope(object);\r\n      } else if (object instanceof Error) {\r\n        out = object.stack || ('' + object.name + ': ' + object.message);\r\n      } else {\r\n        // TODO(i): this prevents methods being logged,\r\n        // we should have a better way to serialize objects\r\n        out = angular.toJson(object, true);\r\n      }\r\n    } else {\r\n      out = String(object);\r\n    }\r\n\r\n    return out;\r\n  }\r\n\r\n  function serializeScope(scope, offset) {\r\n    offset = offset ||  '  ';\r\n    var log = [offset + 'Scope(' + scope.$id + '): {'];\r\n    for (var key in scope) {\r\n      if (Object.prototype.hasOwnProperty.call(scope, key) && !key.match(/^(\\$|this)/)) {\r\n        log.push('  ' + key + ': ' + angular.toJson(scope[key]));\r\n      }\r\n    }\r\n    var child = scope.$$childHead;\r\n    while (child) {\r\n      log.push(serializeScope(child, offset + '  '));\r\n      child = child.$$nextSibling;\r\n    }\r\n    log.push('}');\r\n    return log.join('\\n' + offset);\r\n  }\r\n};\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $httpBackend\r\n * @description\r\n * Fake HTTP backend implementation suitable for unit testing applications that use the\r\n * {@link ng.$http $http service}.\r\n *\r\n * <div class=\"alert alert-info\">\r\n * **Note**: For fake HTTP backend implementation suitable for end-to-end testing or backend-less\r\n * development please see {@link ngMockE2E.$httpBackend e2e $httpBackend mock}.\r\n * </div>\r\n *\r\n * During unit testing, we want our unit tests to run quickly and have no external dependencies so\r\n * we dont want to send [XHR](https://developer.mozilla.org/en/xmlhttprequest) or\r\n * [JSONP](http://en.wikipedia.org/wiki/JSONP) requests to a real server. All we really need is\r\n * to verify whether a certain request has been sent or not, or alternatively just let the\r\n * application make requests, respond with pre-trained responses and assert that the end result is\r\n * what we expect it to be.\r\n *\r\n * This mock implementation can be used to respond with static or dynamic responses via the\r\n * `expect` and `when` apis and their shortcuts (`expectGET`, `whenPOST`, etc).\r\n *\r\n * When an Angular application needs some data from a server, it calls the $http service, which\r\n * sends the request to a real server using $httpBackend service. With dependency injection, it is\r\n * easy to inject $httpBackend mock (which has the same API as $httpBackend) and use it to verify\r\n * the requests and respond with some testing data without sending a request to a real server.\r\n *\r\n * There are two ways to specify what test data should be returned as http responses by the mock\r\n * backend when the code under test makes http requests:\r\n *\r\n * - `$httpBackend.expect` - specifies a request expectation\r\n * - `$httpBackend.when` - specifies a backend definition\r\n *\r\n *\r\n * ## Request Expectations vs Backend Definitions\r\n *\r\n * Request expectations provide a way to make assertions about requests made by the application and\r\n * to define responses for those requests. The test will fail if the expected requests are not made\r\n * or they are made in the wrong order.\r\n *\r\n * Backend definitions allow you to define a fake backend for your application which doesn't assert\r\n * if a particular request was made or not, it just returns a trained response if a request is made.\r\n * The test will pass whether or not the request gets made during testing.\r\n *\r\n *\r\n * <table class=\"table\">\r\n *   <tr><th width=\"220px\"></th><th>Request expectations</th><th>Backend definitions</th></tr>\r\n *   <tr>\r\n *     <th>Syntax</th>\r\n *     <td>.expect(...).respond(...)</td>\r\n *     <td>.when(...).respond(...)</td>\r\n *   </tr>\r\n *   <tr>\r\n *     <th>Typical usage</th>\r\n *     <td>strict unit tests</td>\r\n *     <td>loose (black-box) unit testing</td>\r\n *   </tr>\r\n *   <tr>\r\n *     <th>Fulfills multiple requests</th>\r\n *     <td>NO</td>\r\n *     <td>YES</td>\r\n *   </tr>\r\n *   <tr>\r\n *     <th>Order of requests matters</th>\r\n *     <td>YES</td>\r\n *     <td>NO</td>\r\n *   </tr>\r\n *   <tr>\r\n *     <th>Request required</th>\r\n *     <td>YES</td>\r\n *     <td>NO</td>\r\n *   </tr>\r\n *   <tr>\r\n *     <th>Response required</th>\r\n *     <td>optional (see below)</td>\r\n *     <td>YES</td>\r\n *   </tr>\r\n * </table>\r\n *\r\n * In cases where both backend definitions and request expectations are specified during unit\r\n * testing, the request expectations are evaluated first.\r\n *\r\n * If a request expectation has no response specified, the algorithm will search your backend\r\n * definitions for an appropriate response.\r\n *\r\n * If a request didn't match any expectation or if the expectation doesn't have the response\r\n * defined, the backend definitions are evaluated in sequential order to see if any of them match\r\n * the request. The response from the first matched definition is returned.\r\n *\r\n *\r\n * ## Flushing HTTP requests\r\n *\r\n * The $httpBackend used in production always responds to requests asynchronously. If we preserved\r\n * this behavior in unit testing, we'd have to create async unit tests, which are hard to write,\r\n * to follow and to maintain. But neither can the testing mock respond synchronously; that would\r\n * change the execution of the code under test. For this reason, the mock $httpBackend has a\r\n * `flush()` method, which allows the test to explicitly flush pending requests. This preserves\r\n * the async api of the backend, while allowing the test to execute synchronously.\r\n *\r\n *\r\n * ## Unit testing with mock $httpBackend\r\n * The following code shows how to setup and use the mock backend when unit testing a controller.\r\n * First we create the controller under test:\r\n *\r\n  ```js\r\n  // The module code\r\n  angular\r\n    .module('MyApp', [])\r\n    .controller('MyController', MyController);\r\n\r\n  // The controller code\r\n  function MyController($scope, $http) {\r\n    var authToken;\r\n\r\n    $http.get('/auth.py').then(function(response) {\r\n      authToken = response.headers('A-Token');\r\n      $scope.user = response.data;\r\n    });\r\n\r\n    $scope.saveMessage = function(message) {\r\n      var headers = { 'Authorization': authToken };\r\n      $scope.status = 'Saving...';\r\n\r\n      $http.post('/add-msg.py', message, { headers: headers } ).then(function(response) {\r\n        $scope.status = '';\r\n      }).catch(function() {\r\n        $scope.status = 'Failed...';\r\n      });\r\n    };\r\n  }\r\n  ```\r\n *\r\n * Now we setup the mock backend and create the test specs:\r\n *\r\n  ```js\r\n    // testing controller\r\n    describe('MyController', function() {\r\n       var $httpBackend, $rootScope, createController, authRequestHandler;\r\n\r\n       // Set up the module\r\n       beforeEach(module('MyApp'));\r\n\r\n       beforeEach(inject(function($injector) {\r\n         // Set up the mock http service responses\r\n         $httpBackend = $injector.get('$httpBackend');\r\n         // backend definition common for all tests\r\n         authRequestHandler = $httpBackend.when('GET', '/auth.py')\r\n                                .respond({userId: 'userX'}, {'A-Token': 'xxx'});\r\n\r\n         // Get hold of a scope (i.e. the root scope)\r\n         $rootScope = $injector.get('$rootScope');\r\n         // The $controller service is used to create instances of controllers\r\n         var $controller = $injector.get('$controller');\r\n\r\n         createController = function() {\r\n           return $controller('MyController', {'$scope' : $rootScope });\r\n         };\r\n       }));\r\n\r\n\r\n       afterEach(function() {\r\n         $httpBackend.verifyNoOutstandingExpectation();\r\n         $httpBackend.verifyNoOutstandingRequest();\r\n       });\r\n\r\n\r\n       it('should fetch authentication token', function() {\r\n         $httpBackend.expectGET('/auth.py');\r\n         var controller = createController();\r\n         $httpBackend.flush();\r\n       });\r\n\r\n\r\n       it('should fail authentication', function() {\r\n\r\n         // Notice how you can change the response even after it was set\r\n         authRequestHandler.respond(401, '');\r\n\r\n         $httpBackend.expectGET('/auth.py');\r\n         var controller = createController();\r\n         $httpBackend.flush();\r\n         expect($rootScope.status).toBe('Failed...');\r\n       });\r\n\r\n\r\n       it('should send msg to server', function() {\r\n         var controller = createController();\r\n         $httpBackend.flush();\r\n\r\n         // now you dont care about the authentication, but\r\n         // the controller will still send the request and\r\n         // $httpBackend will respond without you having to\r\n         // specify the expectation and response for this request\r\n\r\n         $httpBackend.expectPOST('/add-msg.py', 'message content').respond(201, '');\r\n         $rootScope.saveMessage('message content');\r\n         expect($rootScope.status).toBe('Saving...');\r\n         $httpBackend.flush();\r\n         expect($rootScope.status).toBe('');\r\n       });\r\n\r\n\r\n       it('should send auth header', function() {\r\n         var controller = createController();\r\n         $httpBackend.flush();\r\n\r\n         $httpBackend.expectPOST('/add-msg.py', undefined, function(headers) {\r\n           // check if the header was sent, if it wasn't the expectation won't\r\n           // match the request and the test will fail\r\n           return headers['Authorization'] === 'xxx';\r\n         }).respond(201, '');\r\n\r\n         $rootScope.saveMessage('whatever');\r\n         $httpBackend.flush();\r\n       });\r\n    });\r\n  ```\r\n *\r\n * ## Dynamic responses\r\n *\r\n * You define a response to a request by chaining a call to `respond()` onto a definition or expectation.\r\n * If you provide a **callback** as the first parameter to `respond(callback)` then you can dynamically generate\r\n * a response based on the properties of the request.\r\n *\r\n * The `callback` function should be of the form `function(method, url, data, headers, params)`.\r\n *\r\n * ### Query parameters\r\n *\r\n * By default, query parameters on request URLs are parsed into the `params` object. So a request URL\r\n * of `/list?q=searchstr&orderby=-name` would set `params` to be `{q: 'searchstr', orderby: '-name'}`.\r\n *\r\n * ### Regex parameter matching\r\n *\r\n * If an expectation or definition uses a **regex** to match the URL, you can provide an array of **keys** via a\r\n * `params` argument. The index of each **key** in the array will match the index of a **group** in the\r\n * **regex**.\r\n *\r\n * The `params` object in the **callback** will now have properties with these keys, which hold the value of the\r\n * corresponding **group** in the **regex**.\r\n *\r\n * This also applies to the `when` and `expect` shortcut methods.\r\n *\r\n *\r\n * ```js\r\n *   $httpBackend.expect('GET', /\\/user\\/(.+)/, undefined, undefined, ['id'])\r\n *     .respond(function(method, url, data, headers, params) {\r\n *       // for requested url of '/user/1234' params is {id: '1234'}\r\n *     });\r\n *\r\n *   $httpBackend.whenPATCH(/\\/user\\/(.+)\\/article\\/(.+)/, undefined, undefined, ['user', 'article'])\r\n *     .respond(function(method, url, data, headers, params) {\r\n *       // for url of '/user/1234/article/567' params is {user: '1234', article: '567'}\r\n *     });\r\n * ```\r\n *\r\n * ## Matching route requests\r\n *\r\n * For extra convenience, `whenRoute` and `expectRoute` shortcuts are available. These methods offer colon\r\n * delimited matching of the url path, ignoring the query string. This allows declarations\r\n * similar to how application routes are configured with `$routeProvider`. Because these methods convert\r\n * the definition url to regex, declaration order is important. Combined with query parameter parsing,\r\n * the following is possible:\r\n *\r\n  ```js\r\n    $httpBackend.whenRoute('GET', '/users/:id')\r\n      .respond(function(method, url, data, headers, params) {\r\n        return [200, MockUserList[Number(params.id)]];\r\n      });\r\n\r\n    $httpBackend.whenRoute('GET', '/users')\r\n      .respond(function(method, url, data, headers, params) {\r\n        var userList = angular.copy(MockUserList),\r\n          defaultSort = 'lastName',\r\n          count, pages, isPrevious, isNext;\r\n\r\n        // paged api response '/v1/users?page=2'\r\n        params.page = Number(params.page) || 1;\r\n\r\n        // query for last names '/v1/users?q=Archer'\r\n        if (params.q) {\r\n          userList = $filter('filter')({lastName: params.q});\r\n        }\r\n\r\n        pages = Math.ceil(userList.length / pagingLength);\r\n        isPrevious = params.page > 1;\r\n        isNext = params.page < pages;\r\n\r\n        return [200, {\r\n          count:    userList.length,\r\n          previous: isPrevious,\r\n          next:     isNext,\r\n          // sort field -> '/v1/users?sortBy=firstName'\r\n          results:  $filter('orderBy')(userList, params.sortBy || defaultSort)\r\n                      .splice((params.page - 1) * pagingLength, pagingLength)\r\n        }];\r\n      });\r\n  ```\r\n */\r\nangular.mock.$httpBackendDecorator =\r\n  ['$rootScope', '$timeout', '$delegate', createHttpBackendMock];\r\n\r\n/**\r\n * General factory function for $httpBackend mock.\r\n * Returns instance for unit testing (when no arguments specified):\r\n *   - passing through is disabled\r\n *   - auto flushing is disabled\r\n *\r\n * Returns instance for e2e testing (when `$delegate` and `$browser` specified):\r\n *   - passing through (delegating request to real backend) is enabled\r\n *   - auto flushing is enabled\r\n *\r\n * @param {Object=} $delegate Real $httpBackend instance (allow passing through if specified)\r\n * @param {Object=} $browser Auto-flushing enabled if specified\r\n * @return {Object} Instance of $httpBackend mock\r\n */\r\nfunction createHttpBackendMock($rootScope, $timeout, $delegate, $browser) {\r\n  var definitions = [],\r\n      expectations = [],\r\n      responses = [],\r\n      responsesPush = angular.bind(responses, responses.push),\r\n      copy = angular.copy,\r\n      // We cache the original backend so that if both ngMock and ngMockE2E override the\r\n      // service the ngMockE2E version can pass through to the real backend\r\n      originalHttpBackend = $delegate.$$originalHttpBackend || $delegate;\r\n\r\n  function createResponse(status, data, headers, statusText) {\r\n    if (angular.isFunction(status)) return status;\r\n\r\n    return function() {\r\n      return angular.isNumber(status)\r\n          ? [status, data, headers, statusText]\r\n          : [200, status, data, headers];\r\n    };\r\n  }\r\n\r\n  // TODO(vojta): change params to: method, url, data, headers, callback\r\n  function $httpBackend(method, url, data, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {\r\n\r\n    var xhr = new MockXhr(),\r\n        expectation = expectations[0],\r\n        wasExpected = false;\r\n\r\n    xhr.$$events = eventHandlers;\r\n    xhr.upload.$$events = uploadEventHandlers;\r\n\r\n    function prettyPrint(data) {\r\n      return (angular.isString(data) || angular.isFunction(data) || data instanceof RegExp)\r\n          ? data\r\n          : angular.toJson(data);\r\n    }\r\n\r\n    function wrapResponse(wrapped) {\r\n      if (!$browser && timeout) {\r\n        if (timeout.then) {\r\n          timeout.then(handleTimeout);\r\n        } else {\r\n          $timeout(handleTimeout, timeout);\r\n        }\r\n      }\r\n\r\n      return handleResponse;\r\n\r\n      function handleResponse() {\r\n        var response = wrapped.response(method, url, data, headers, wrapped.params(url));\r\n        xhr.$$respHeaders = response[2];\r\n        callback(copy(response[0]), copy(response[1]), xhr.getAllResponseHeaders(),\r\n                 copy(response[3] || ''));\r\n      }\r\n\r\n      function handleTimeout() {\r\n        for (var i = 0, ii = responses.length; i < ii; i++) {\r\n          if (responses[i] === handleResponse) {\r\n            responses.splice(i, 1);\r\n            callback(-1, undefined, '');\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (expectation && expectation.match(method, url)) {\r\n      if (!expectation.matchData(data)) {\r\n        throw new Error('Expected ' + expectation + ' with different data\\n' +\r\n            'EXPECTED: ' + prettyPrint(expectation.data) + '\\nGOT:      ' + data);\r\n      }\r\n\r\n      if (!expectation.matchHeaders(headers)) {\r\n        throw new Error('Expected ' + expectation + ' with different headers\\n' +\r\n                        'EXPECTED: ' + prettyPrint(expectation.headers) + '\\nGOT:      ' +\r\n                        prettyPrint(headers));\r\n      }\r\n\r\n      expectations.shift();\r\n\r\n      if (expectation.response) {\r\n        responses.push(wrapResponse(expectation));\r\n        return;\r\n      }\r\n      wasExpected = true;\r\n    }\r\n\r\n    var i = -1, definition;\r\n    while ((definition = definitions[++i])) {\r\n      if (definition.match(method, url, data, headers || {})) {\r\n        if (definition.response) {\r\n          // if $browser specified, we do auto flush all requests\r\n          ($browser ? $browser.defer : responsesPush)(wrapResponse(definition));\r\n        } else if (definition.passThrough) {\r\n          originalHttpBackend(method, url, data, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers);\r\n        } else throw new Error('No response defined !');\r\n        return;\r\n      }\r\n    }\r\n    throw wasExpected ?\r\n        new Error('No response defined !') :\r\n        new Error('Unexpected request: ' + method + ' ' + url + '\\n' +\r\n                  (expectation ? 'Expected ' + expectation : 'No more request expected'));\r\n  }\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#when\r\n   * @description\r\n   * Creates a new backend definition.\r\n   *\r\n   * @param {string} method HTTP method.\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\r\n   *   data string and returns true if the data is as expected.\r\n   * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header\r\n   *   object and returns true if the headers match the current definition.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *   request is handled. You can save this object for later use and invoke `respond` again in\r\n   *   order to change how a matched request is handled.\r\n   *\r\n   *  - respond \r\n   *      ```js\r\n   *      {function([status,] data[, headers, statusText])\r\n   *      | function(function(method, url, data, headers, params)}\r\n   *      ```\r\n   *     The respond method takes a set of static data to be returned or a function that can\r\n   *    return an array containing response status (number), response data (Array|Object|string),\r\n   *    response headers (Object), and the text for the status (string). The respond method returns\r\n   *    the `requestHandler` object for possible overrides.\r\n   */\r\n  $httpBackend.when = function(method, url, data, headers, keys) {\r\n\r\n    assertArgDefined(arguments, 1, 'url');\r\n\r\n    var definition = new MockHttpExpectation(method, url, data, headers, keys),\r\n        chain = {\r\n          respond: function(status, data, headers, statusText) {\r\n            definition.passThrough = undefined;\r\n            definition.response = createResponse(status, data, headers, statusText);\r\n            return chain;\r\n          }\r\n        };\r\n\r\n    if ($browser) {\r\n      chain.passThrough = function() {\r\n        definition.response = undefined;\r\n        definition.passThrough = true;\r\n        return chain;\r\n      };\r\n    }\r\n\r\n    definitions.push(definition);\r\n    return chain;\r\n  };\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#whenGET\r\n   * @description\r\n   * Creates a new backend definition for GET requests. For more info see `when()`.\r\n   *\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(Object|function(Object))=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#whenHEAD\r\n   * @description\r\n   * Creates a new backend definition for HEAD requests. For more info see `when()`.\r\n   *\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(Object|function(Object))=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#whenDELETE\r\n   * @description\r\n   * Creates a new backend definition for DELETE requests. For more info see `when()`.\r\n   *\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(Object|function(Object))=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#whenPOST\r\n   * @description\r\n   * Creates a new backend definition for POST requests. For more info see `when()`.\r\n   *\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\r\n   *   data string and returns true if the data is as expected.\r\n   * @param {(Object|function(Object))=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#whenPUT\r\n   * @description\r\n   * Creates a new backend definition for PUT requests.  For more info see `when()`.\r\n   *\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\r\n   *   data string and returns true if the data is as expected.\r\n   * @param {(Object|function(Object))=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#whenJSONP\r\n   * @description\r\n   * Creates a new backend definition for JSONP requests. For more info see `when()`.\r\n   *\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled.\r\n   */\r\n  createShortMethods('when');\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#whenRoute\r\n   * @description\r\n   * Creates a new backend definition that compares only with the requested route.\r\n   *\r\n   * @param {string} method HTTP method.\r\n   * @param {string} url HTTP url string that supports colon param matching.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled. See #when for more info.\r\n   */\r\n  $httpBackend.whenRoute = function(method, url) {\r\n    var pathObj = parseRoute(url);\r\n    return $httpBackend.when(method, pathObj.regexp, undefined, undefined, pathObj.keys);\r\n  };\r\n\r\n  function parseRoute(url) {\r\n    var ret = {\r\n      regexp: url\r\n    },\r\n    keys = ret.keys = [];\r\n\r\n    if (!url || !angular.isString(url)) return ret;\r\n\r\n    url = url\r\n      .replace(/([().])/g, '\\\\$1')\r\n      .replace(/(\\/)?:(\\w+)([?*])?/g, function(_, slash, key, option) {\r\n        var optional = option === '?' ? option : null;\r\n        var star = option === '*' ? option : null;\r\n        keys.push({ name: key, optional: !!optional });\r\n        slash = slash || '';\r\n        return ''\r\n          + (optional ? '' : slash)\r\n          + '(?:'\r\n          + (optional ? slash : '')\r\n          + (star && '(.+?)' || '([^/]+)')\r\n          + (optional || '')\r\n          + ')'\r\n          + (optional || '');\r\n      })\r\n      .replace(/([/$*])/g, '\\\\$1');\r\n\r\n    ret.regexp = new RegExp('^' + url, 'i');\r\n    return ret;\r\n  }\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expect\r\n   * @description\r\n   * Creates a new request expectation.\r\n   *\r\n   * @param {string} method HTTP method.\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\r\n   *  receives data string and returns true if the data is as expected, or Object if request body\r\n   *  is in JSON format.\r\n   * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header\r\n   *   object and returns true if the headers match the current expectation.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *  request is handled. You can save this object for later use and invoke `respond` again in\r\n   *  order to change how a matched request is handled.\r\n   *\r\n   *  - respond \r\n   *    ```\r\n   *    { function([status,] data[, headers, statusText])\r\n   *    | function(function(method, url, data, headers, params)}\r\n   *    ```\r\n   *     The respond method takes a set of static data to be returned or a function that can\r\n   *    return an array containing response status (number), response data (Array|Object|string),\r\n   *    response headers (Object), and the text for the status (string). The respond method returns\r\n   *    the `requestHandler` object for possible overrides.\r\n   */\r\n  $httpBackend.expect = function(method, url, data, headers, keys) {\r\n\r\n    assertArgDefined(arguments, 1, 'url');\r\n\r\n    var expectation = new MockHttpExpectation(method, url, data, headers, keys),\r\n        chain = {\r\n          respond: function(status, data, headers, statusText) {\r\n            expectation.response = createResponse(status, data, headers, statusText);\r\n            return chain;\r\n          }\r\n        };\r\n\r\n    expectations.push(expectation);\r\n    return chain;\r\n  };\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectGET\r\n   * @description\r\n   * Creates a new request expectation for GET requests. For more info see `expect()`.\r\n   *\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {Object=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled. See #expect for more info.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectHEAD\r\n   * @description\r\n   * Creates a new request expectation for HEAD requests. For more info see `expect()`.\r\n   *\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {Object=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *   request is handled. You can save this object for later use and invoke `respond` again in\r\n   *   order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectDELETE\r\n   * @description\r\n   * Creates a new request expectation for DELETE requests. For more info see `expect()`.\r\n   *\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {Object=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *   request is handled. You can save this object for later use and invoke `respond` again in\r\n   *   order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectPOST\r\n   * @description\r\n   * Creates a new request expectation for POST requests. For more info see `expect()`.\r\n   *\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\r\n   *  receives data string and returns true if the data is as expected, or Object if request body\r\n   *  is in JSON format.\r\n   * @param {Object=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *   request is handled. You can save this object for later use and invoke `respond` again in\r\n   *   order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectPUT\r\n   * @description\r\n   * Creates a new request expectation for PUT requests. For more info see `expect()`.\r\n   *\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\r\n   *  receives data string and returns true if the data is as expected, or Object if request body\r\n   *  is in JSON format.\r\n   * @param {Object=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *   request is handled. You can save this object for later use and invoke `respond` again in\r\n   *   order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectPATCH\r\n   * @description\r\n   * Creates a new request expectation for PATCH requests. For more info see `expect()`.\r\n   *\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\r\n   *  receives data string and returns true if the data is as expected, or Object if request body\r\n   *  is in JSON format.\r\n   * @param {Object=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *   request is handled. You can save this object for later use and invoke `respond` again in\r\n   *   order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectJSONP\r\n   * @description\r\n   * Creates a new request expectation for JSONP requests. For more info see `expect()`.\r\n   *\r\n   * @param {string|RegExp|function(string)=} url HTTP url or function that receives an url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *   request is handled. You can save this object for later use and invoke `respond` again in\r\n   *   order to change how a matched request is handled.\r\n   */\r\n  createShortMethods('expect');\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectRoute\r\n   * @description\r\n   * Creates a new request expectation that compares only with the requested route.\r\n   *\r\n   * @param {string} method HTTP method.\r\n   * @param {string} url HTTP url string that supports colon param matching.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled. See #expect for more info.\r\n   */\r\n  $httpBackend.expectRoute = function(method, url) {\r\n    var pathObj = parseRoute(url);\r\n    return $httpBackend.expect(method, pathObj.regexp, undefined, undefined, pathObj.keys);\r\n  };\r\n\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#flush\r\n   * @description\r\n   * Flushes pending requests using the trained responses. Requests are flushed in the order they\r\n   * were made, but it is also possible to skip one or more requests (for example to have them\r\n   * flushed later). This is useful for simulating scenarios where responses arrive from the server\r\n   * in any order.\r\n   *\r\n   * If there are no pending requests to flush when the method is called, an exception is thrown (as\r\n   * this is typically a sign of programming error).\r\n   *\r\n   * @param {number=} count - Number of responses to flush. If undefined/null, all pending requests\r\n   *     (starting after `skip`) will be flushed.\r\n   * @param {number=} [skip=0] - Number of pending requests to skip. For example, a value of `5`\r\n   *     would skip the first 5 pending requests and start flushing from the 6th onwards.\r\n   */\r\n  $httpBackend.flush = function(count, skip, digest) {\r\n    if (digest !== false) $rootScope.$digest();\r\n\r\n    skip = skip || 0;\r\n    if (skip >= responses.length) throw new Error('No pending request to flush !');\r\n\r\n    if (angular.isDefined(count) && count !== null) {\r\n      while (count--) {\r\n        var part = responses.splice(skip, 1);\r\n        if (!part.length) throw new Error('No more pending request to flush !');\r\n        part[0]();\r\n      }\r\n    } else {\r\n      while (responses.length > skip) {\r\n        responses.splice(skip, 1)[0]();\r\n      }\r\n    }\r\n    $httpBackend.verifyNoOutstandingExpectation(digest);\r\n  };\r\n\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#verifyNoOutstandingExpectation\r\n   * @description\r\n   * Verifies that all of the requests defined via the `expect` api were made. If any of the\r\n   * requests were not made, verifyNoOutstandingExpectation throws an exception.\r\n   *\r\n   * Typically, you would call this method following each test case that asserts requests using an\r\n   * \"afterEach\" clause.\r\n   *\r\n   * ```js\r\n   *   afterEach($httpBackend.verifyNoOutstandingExpectation);\r\n   * ```\r\n   */\r\n  $httpBackend.verifyNoOutstandingExpectation = function(digest) {\r\n    if (digest !== false) $rootScope.$digest();\r\n    if (expectations.length) {\r\n      throw new Error('Unsatisfied requests: ' + expectations.join(', '));\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#verifyNoOutstandingRequest\r\n   * @description\r\n   * Verifies that there are no outstanding requests that need to be flushed.\r\n   *\r\n   * Typically, you would call this method following each test case that asserts requests using an\r\n   * \"afterEach\" clause.\r\n   *\r\n   * ```js\r\n   *   afterEach($httpBackend.verifyNoOutstandingRequest);\r\n   * ```\r\n   */\r\n  $httpBackend.verifyNoOutstandingRequest = function(digest) {\r\n    if (digest !== false) $rootScope.$digest();\r\n    if (responses.length) {\r\n      throw new Error('Unflushed requests: ' + responses.length);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#resetExpectations\r\n   * @description\r\n   * Resets all request expectations, but preserves all backend definitions. Typically, you would\r\n   * call resetExpectations during a multiple-phase test when you want to reuse the same instance of\r\n   * $httpBackend mock.\r\n   */\r\n  $httpBackend.resetExpectations = function() {\r\n    expectations.length = 0;\r\n    responses.length = 0;\r\n  };\r\n\r\n  $httpBackend.$$originalHttpBackend = originalHttpBackend;\r\n\r\n  return $httpBackend;\r\n\r\n\r\n  function createShortMethods(prefix) {\r\n    angular.forEach(['GET', 'DELETE', 'JSONP', 'HEAD'], function(method) {\r\n     $httpBackend[prefix + method] = function(url, headers, keys) {\r\n        assertArgDefined(arguments, 0, 'url');\r\n\r\n        // Change url to `null` if `undefined` to stop it throwing an exception further down\r\n        if (angular.isUndefined(url)) url = null;\r\n\r\n       return $httpBackend[prefix](method, url, undefined, headers, keys);\r\n     };\r\n    });\r\n\r\n    angular.forEach(['PUT', 'POST', 'PATCH'], function(method) {\r\n      $httpBackend[prefix + method] = function(url, data, headers, keys) {\r\n        assertArgDefined(arguments, 0, 'url');\r\n\r\n        // Change url to `null` if `undefined` to stop it throwing an exception further down\r\n        if (angular.isUndefined(url)) url = null;\r\n\r\n        return $httpBackend[prefix](method, url, data, headers, keys);\r\n      };\r\n    });\r\n  }\r\n}\r\n\r\nfunction assertArgDefined(args, index, name) {\r\n  if (args.length > index && angular.isUndefined(args[index])) {\r\n    throw new Error('Undefined argument `' + name + '`; the argument is provided but not defined');\r\n  }\r\n}\r\n\r\n\r\nfunction MockHttpExpectation(method, url, data, headers, keys) {\r\n\r\n  function getUrlParams(u) {\r\n    var params = u.slice(u.indexOf('?') + 1).split('&');\r\n    return params.sort();\r\n  }\r\n\r\n  function compareUrl(u) {\r\n    return (url.slice(0, url.indexOf('?')) === u.slice(0, u.indexOf('?')) &&\r\n      getUrlParams(url).join() === getUrlParams(u).join());\r\n  }\r\n\r\n  this.data = data;\r\n  this.headers = headers;\r\n\r\n  this.match = function(m, u, d, h) {\r\n    if (method !== m) return false;\r\n    if (!this.matchUrl(u)) return false;\r\n    if (angular.isDefined(d) && !this.matchData(d)) return false;\r\n    if (angular.isDefined(h) && !this.matchHeaders(h)) return false;\r\n    return true;\r\n  };\r\n\r\n  this.matchUrl = function(u) {\r\n    if (!url) return true;\r\n    if (angular.isFunction(url.test)) return url.test(u);\r\n    if (angular.isFunction(url)) return url(u);\r\n    return (url === u || compareUrl(u));\r\n  };\r\n\r\n  this.matchHeaders = function(h) {\r\n    if (angular.isUndefined(headers)) return true;\r\n    if (angular.isFunction(headers)) return headers(h);\r\n    return angular.equals(headers, h);\r\n  };\r\n\r\n  this.matchData = function(d) {\r\n    if (angular.isUndefined(data)) return true;\r\n    if (data && angular.isFunction(data.test)) return data.test(d);\r\n    if (data && angular.isFunction(data)) return data(d);\r\n    if (data && !angular.isString(data)) {\r\n      return angular.equals(angular.fromJson(angular.toJson(data)), angular.fromJson(d));\r\n    }\r\n    // eslint-disable-next-line eqeqeq\r\n    return data == d;\r\n  };\r\n\r\n  this.toString = function() {\r\n    return method + ' ' + url;\r\n  };\r\n\r\n  this.params = function(u) {\r\n    return angular.extend(parseQuery(), pathParams());\r\n\r\n    function pathParams() {\r\n      var keyObj = {};\r\n      if (!url || !angular.isFunction(url.test) || !keys || keys.length === 0) return keyObj;\r\n\r\n      var m = url.exec(u);\r\n      if (!m) return keyObj;\r\n      for (var i = 1, len = m.length; i < len; ++i) {\r\n        var key = keys[i - 1];\r\n        var val = m[i];\r\n        if (key && val) {\r\n          keyObj[key.name || key] = val;\r\n        }\r\n      }\r\n\r\n      return keyObj;\r\n    }\r\n\r\n    function parseQuery() {\r\n      var obj = {}, key_value, key,\r\n          queryStr = u.indexOf('?') > -1\r\n          ? u.substring(u.indexOf('?') + 1)\r\n          : '';\r\n\r\n      angular.forEach(queryStr.split('&'), function(keyValue) {\r\n        if (keyValue) {\r\n          key_value = keyValue.replace(/\\+/g,'%20').split('=');\r\n          key = tryDecodeURIComponent(key_value[0]);\r\n          if (angular.isDefined(key)) {\r\n            var val = angular.isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;\r\n            if (!hasOwnProperty.call(obj, key)) {\r\n              obj[key] = val;\r\n            } else if (angular.isArray(obj[key])) {\r\n              obj[key].push(val);\r\n            } else {\r\n              obj[key] = [obj[key],val];\r\n            }\r\n          }\r\n        }\r\n      });\r\n      return obj;\r\n    }\r\n    function tryDecodeURIComponent(value) {\r\n      try {\r\n        return decodeURIComponent(value);\r\n      } catch (e) {\r\n        // Ignore any invalid uri component\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nfunction createMockXhr() {\r\n  return new MockXhr();\r\n}\r\n\r\nfunction MockXhr() {\r\n\r\n  // hack for testing $http, $httpBackend\r\n  MockXhr.$$lastInstance = this;\r\n\r\n  this.open = function(method, url, async) {\r\n    this.$$method = method;\r\n    this.$$url = url;\r\n    this.$$async = async;\r\n    this.$$reqHeaders = {};\r\n    this.$$respHeaders = {};\r\n  };\r\n\r\n  this.send = function(data) {\r\n    this.$$data = data;\r\n  };\r\n\r\n  this.setRequestHeader = function(key, value) {\r\n    this.$$reqHeaders[key] = value;\r\n  };\r\n\r\n  this.getResponseHeader = function(name) {\r\n    // the lookup must be case insensitive,\r\n    // that's why we try two quick lookups first and full scan last\r\n    var header = this.$$respHeaders[name];\r\n    if (header) return header;\r\n\r\n    name = angular.lowercase(name);\r\n    header = this.$$respHeaders[name];\r\n    if (header) return header;\r\n\r\n    header = undefined;\r\n    angular.forEach(this.$$respHeaders, function(headerVal, headerName) {\r\n      if (!header && angular.lowercase(headerName) === name) header = headerVal;\r\n    });\r\n    return header;\r\n  };\r\n\r\n  this.getAllResponseHeaders = function() {\r\n    var lines = [];\r\n\r\n    angular.forEach(this.$$respHeaders, function(value, key) {\r\n      lines.push(key + ': ' + value);\r\n    });\r\n    return lines.join('\\n');\r\n  };\r\n\r\n  this.abort = angular.noop;\r\n\r\n  // This section simulates the events on a real XHR object (and the upload object)\r\n  // When we are testing $httpBackend (inside the angular project) we make partial use of this\r\n  // but store the events directly ourselves on `$$events`, instead of going through the `addEventListener`\r\n  this.$$events = {};\r\n  this.addEventListener = function(name, listener) {\r\n    if (angular.isUndefined(this.$$events[name])) this.$$events[name] = [];\r\n    this.$$events[name].push(listener);\r\n  };\r\n\r\n  this.upload = {\r\n    $$events: {},\r\n    addEventListener: this.addEventListener\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $timeout\r\n * @description\r\n *\r\n * This service is just a simple decorator for {@link ng.$timeout $timeout} service\r\n * that adds a \"flush\" and \"verifyNoPendingTasks\" methods.\r\n */\r\n\r\nangular.mock.$TimeoutDecorator = ['$delegate', '$browser', function($delegate, $browser) {\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $timeout#flush\r\n   * @description\r\n   *\r\n   * Flushes the queue of pending tasks.\r\n   *\r\n   * @param {number=} delay maximum timeout amount to flush up until\r\n   */\r\n  $delegate.flush = function(delay) {\r\n    $browser.defer.flush(delay);\r\n  };\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $timeout#verifyNoPendingTasks\r\n   * @description\r\n   *\r\n   * Verifies that there are no pending tasks that need to be flushed.\r\n   */\r\n  $delegate.verifyNoPendingTasks = function() {\r\n    if ($browser.deferredFns.length) {\r\n      throw new Error('Deferred tasks to flush (' + $browser.deferredFns.length + '): ' +\r\n          formatPendingTasksAsString($browser.deferredFns));\r\n    }\r\n  };\r\n\r\n  function formatPendingTasksAsString(tasks) {\r\n    var result = [];\r\n    angular.forEach(tasks, function(task) {\r\n      result.push('{id: ' + task.id + ', time: ' + task.time + '}');\r\n    });\r\n\r\n    return result.join(', ');\r\n  }\r\n\r\n  return $delegate;\r\n}];\r\n\r\nangular.mock.$RAFDecorator = ['$delegate', function($delegate) {\r\n  var rafFn = function(fn) {\r\n    var index = rafFn.queue.length;\r\n    rafFn.queue.push(fn);\r\n    return function() {\r\n      rafFn.queue.splice(index, 1);\r\n    };\r\n  };\r\n\r\n  rafFn.queue = [];\r\n  rafFn.supported = $delegate.supported;\r\n\r\n  rafFn.flush = function() {\r\n    if (rafFn.queue.length === 0) {\r\n      throw new Error('No rAF callbacks present');\r\n    }\r\n\r\n    var length = rafFn.queue.length;\r\n    for (var i = 0; i < length; i++) {\r\n      rafFn.queue[i]();\r\n    }\r\n\r\n    rafFn.queue = rafFn.queue.slice(i);\r\n  };\r\n\r\n  return rafFn;\r\n}];\r\n\r\n/**\r\n *\r\n */\r\nvar originalRootElement;\r\nangular.mock.$RootElementProvider = function() {\r\n  this.$get = ['$injector', function($injector) {\r\n    originalRootElement = angular.element('<div ng-app></div>').data('$injector', $injector);\r\n    return originalRootElement;\r\n  }];\r\n};\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $controller\r\n * @description\r\n * A decorator for {@link ng.$controller} with additional `bindings` parameter, useful when testing\r\n * controllers of directives that use {@link $compile#-bindtocontroller- `bindToController`}.\r\n *\r\n * Depending on the value of\r\n * {@link ng.$compileProvider#preAssignBindingsEnabled `preAssignBindingsEnabled()`}, the properties\r\n * will be bound before or after invoking the constructor.\r\n *\r\n *\r\n * ## Example\r\n *\r\n * ```js\r\n *\r\n * // Directive definition ...\r\n *\r\n * myMod.directive('myDirective', {\r\n *   controller: 'MyDirectiveController',\r\n *   bindToController: {\r\n *     name: '@'\r\n *   }\r\n * });\r\n *\r\n *\r\n * // Controller definition ...\r\n *\r\n * myMod.controller('MyDirectiveController', ['$log', function($log) {\r\n *   this.log = function() {\r\n *     $log.info(this.name);\r\n *   };\r\n * }]);\r\n *\r\n *\r\n * // In a test ...\r\n *\r\n * describe('myDirectiveController', function() {\r\n *   describe('log()', function() {\r\n *     it('should write the bound name to the log', inject(function($controller, $log) {\r\n *       var ctrl = $controller('MyDirectiveController', { /* no locals &#42;/ }, { name: 'Clark Kent' });\r\n *       ctrl.log();\r\n *\r\n *       expect(ctrl.name).toEqual('Clark Kent');\r\n *       expect($log.info.logs).toEqual(['Clark Kent']);\r\n *     }));\r\n *   });\r\n * });\r\n *\r\n * ```\r\n *\r\n * @param {Function|string} constructor If called with a function then it's considered to be the\r\n *    controller constructor function. Otherwise it's considered to be a string which is used\r\n *    to retrieve the controller constructor using the following steps:\r\n *\r\n *    * check if a controller with given name is registered via `$controllerProvider`\r\n *    * check if evaluating the string on the current scope returns a constructor\r\n *    * if $controllerProvider#allowGlobals, check `window[constructor]` on the global\r\n *      `window` object (deprecated, not recommended)\r\n *\r\n *    The string can use the `controller as property` syntax, where the controller instance is published\r\n *    as the specified property on the `scope`; the `scope` must be injected into `locals` param for this\r\n *    to work correctly.\r\n *\r\n * @param {Object} locals Injection locals for Controller.\r\n * @param {Object=} bindings Properties to add to the controller instance. This is used to simulate\r\n *                           the `bindToController` feature and simplify certain kinds of tests.\r\n * @return {Object} Instance of given controller.\r\n */\r\nfunction createControllerDecorator(compileProvider) {\r\n  angular.mock.$ControllerDecorator = ['$delegate', function($delegate) {\r\n    return function(expression, locals, later, ident) {\r\n      if (later && typeof later === 'object') {\r\n        var preAssignBindingsEnabled = compileProvider.preAssignBindingsEnabled();\r\n\r\n        var instantiate = $delegate(expression, locals, true, ident);\r\n        if (preAssignBindingsEnabled) {\r\n          angular.extend(instantiate.instance, later);\r\n        }\r\n\r\n        var instance = instantiate();\r\n        if (!preAssignBindingsEnabled || instance !== instantiate.instance) {\r\n          angular.extend(instance, later);\r\n        }\r\n\r\n        return instance;\r\n      }\r\n      return $delegate(expression, locals, later, ident);\r\n    };\r\n  }];\r\n\r\n  return angular.mock.$ControllerDecorator;\r\n}\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $componentController\r\n * @description\r\n * A service that can be used to create instances of component controllers. Useful for unit-testing.\r\n *\r\n * Be aware that the controller will be instantiated and attached to the scope as specified in\r\n * the component definition object. If you do not provide a `$scope` object in the `locals` param\r\n * then the helper will create a new isolated scope as a child of `$rootScope`.\r\n *\r\n * If you are using `$element` or `$attrs` in the controller, make sure to provide them as `locals`.\r\n * The `$element` must be a jqLite-wrapped DOM element, and `$attrs` should be an object that\r\n * has all properties / functions that you are using in the controller. If this is getting too complex,\r\n * you should compile the component instead and access the component's controller via the\r\n * {@link angular.element#methods `controller`} function.\r\n *\r\n * See also the section on {@link guide/component#unit-testing-component-controllers unit-testing component controllers}\r\n * in the guide.\r\n *\r\n * @param {string} componentName the name of the component whose controller we want to instantiate\r\n * @param {Object} locals Injection locals for Controller.\r\n * @param {Object=} bindings Properties to add to the controller before invoking the constructor. This is used\r\n *                           to simulate the `bindToController` feature and simplify certain kinds of tests.\r\n * @param {string=} ident Override the property name to use when attaching the controller to the scope.\r\n * @return {Object} Instance of requested controller.\r\n */\r\nangular.mock.$ComponentControllerProvider = ['$compileProvider',\r\n    function ComponentControllerProvider($compileProvider) {\r\n  this.$get = ['$controller','$injector', '$rootScope', function($controller, $injector, $rootScope) {\r\n    return function $componentController(componentName, locals, bindings, ident) {\r\n      // get all directives associated to the component name\r\n      var directives = $injector.get(componentName + 'Directive');\r\n      // look for those directives that are components\r\n      var candidateDirectives = directives.filter(function(directiveInfo) {\r\n        // components have controller, controllerAs and restrict:'E'\r\n        return directiveInfo.controller && directiveInfo.controllerAs && directiveInfo.restrict === 'E';\r\n      });\r\n      // check if valid directives found\r\n      if (candidateDirectives.length === 0) {\r\n        throw new Error('No component found');\r\n      }\r\n      if (candidateDirectives.length > 1) {\r\n        throw new Error('Too many components found');\r\n      }\r\n      // get the info of the component\r\n      var directiveInfo = candidateDirectives[0];\r\n      // create a scope if needed\r\n      locals = locals || {};\r\n      locals.$scope = locals.$scope || $rootScope.$new(true);\r\n      return $controller(directiveInfo.controller, locals, bindings, ident || directiveInfo.controllerAs);\r\n    };\r\n  }];\r\n}];\r\n\r\n\r\n/**\r\n * @ngdoc module\r\n * @name ngMock\r\n * @packageName angular-mocks\r\n * @description\r\n *\r\n * # ngMock\r\n *\r\n * The `ngMock` module provides support to inject and mock Angular services into unit tests.\r\n * In addition, ngMock also extends various core ng services such that they can be\r\n * inspected and controlled in a synchronous manner within test code.\r\n *\r\n *\r\n * <div doc-module-components=\"ngMock\"></div>\r\n *\r\n * @installation\r\n *\r\n *  First, download the file:\r\n *  * [Google CDN](https://developers.google.com/speed/libraries/devguide#angularjs) e.g.\r\n *    `\"//ajax.googleapis.com/ajax/libs/angularjs/X.Y.Z/angular-mocks.js\"`\r\n *  * [NPM](https://www.npmjs.com/) e.g. `npm install angular-mocks@X.Y.Z`\r\n *  * [Yarn](https://yarnpkg.com) e.g. `yarn add angular-mocks@X.Y.Z`\r\n *  * [Bower](http://bower.io) e.g. `bower install angular-mocks#X.Y.Z`\r\n *  * [code.angularjs.org](https://code.angularjs.org/) (discouraged for production use)  e.g.\r\n *    `\"//code.angularjs.org/X.Y.Z/angular-mocks.js\"`\r\n *\r\n * where X.Y.Z is the AngularJS version you are running.\r\n *\r\n * Then, configure your test runner to load `angular-mocks.js` after `angular.js`.\r\n * This example uses <a href=\"http://karma-runner.github.io/\">Karma</a>:\r\n *\r\n * ```\r\n * config.set({\r\n *   files: [\r\n *     'build/angular.js', // and other module files you need\r\n *     'build/angular-mocks.js',\r\n *     '<path/to/application/files>',\r\n *     '<path/to/spec/files>'\r\n *   ]\r\n * });\r\n * ```\r\n *\r\n * Including the `angular-mocks.js` file automatically adds the `ngMock` module, so your tests\r\n *  are ready to go!\r\n */\r\nangular.module('ngMock', ['ng']).provider({\r\n  $browser: angular.mock.$BrowserProvider,\r\n  $exceptionHandler: angular.mock.$ExceptionHandlerProvider,\r\n  $log: angular.mock.$LogProvider,\r\n  $interval: angular.mock.$IntervalProvider,\r\n  $rootElement: angular.mock.$RootElementProvider,\r\n  $componentController: angular.mock.$ComponentControllerProvider\r\n}).config(['$provide', '$compileProvider', function($provide, $compileProvider) {\r\n  $provide.decorator('$timeout', angular.mock.$TimeoutDecorator);\r\n  $provide.decorator('$$rAF', angular.mock.$RAFDecorator);\r\n  $provide.decorator('$rootScope', angular.mock.$RootScopeDecorator);\r\n  $provide.decorator('$controller', createControllerDecorator($compileProvider));\r\n  $provide.decorator('$httpBackend', angular.mock.$httpBackendDecorator);\r\n}]);\r\n\r\n/**\r\n * @ngdoc module\r\n * @name ngMockE2E\r\n * @module ngMockE2E\r\n * @packageName angular-mocks\r\n * @description\r\n *\r\n * The `ngMockE2E` is an angular module which contains mocks suitable for end-to-end testing.\r\n * Currently there is only one mock present in this module -\r\n * the {@link ngMockE2E.$httpBackend e2e $httpBackend} mock.\r\n */\r\nangular.module('ngMockE2E', ['ng']).config(['$provide', function($provide) {\r\n  $provide.decorator('$httpBackend', angular.mock.e2e.$httpBackendDecorator);\r\n}]);\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $httpBackend\r\n * @module ngMockE2E\r\n * @description\r\n * Fake HTTP backend implementation suitable for end-to-end testing or backend-less development of\r\n * applications that use the {@link ng.$http $http service}.\r\n *\r\n * <div class=\"alert alert-info\">\r\n * **Note**: For fake http backend implementation suitable for unit testing please see\r\n * {@link ngMock.$httpBackend unit-testing $httpBackend mock}.\r\n * </div>\r\n *\r\n * This implementation can be used to respond with static or dynamic responses via the `when` api\r\n * and its shortcuts (`whenGET`, `whenPOST`, etc) and optionally pass through requests to the\r\n * real $httpBackend for specific requests (e.g. to interact with certain remote apis or to fetch\r\n * templates from a webserver).\r\n *\r\n * As opposed to unit-testing, in an end-to-end testing scenario or in scenario when an application\r\n * is being developed with the real backend api replaced with a mock, it is often desirable for\r\n * certain category of requests to bypass the mock and issue a real http request (e.g. to fetch\r\n * templates or static files from the webserver). To configure the backend with this behavior\r\n * use the `passThrough` request handler of `when` instead of `respond`.\r\n *\r\n * Additionally, we don't want to manually have to flush mocked out requests like we do during unit\r\n * testing. For this reason the e2e $httpBackend flushes mocked out requests\r\n * automatically, closely simulating the behavior of the XMLHttpRequest object.\r\n *\r\n * To setup the application to run with this http backend, you have to create a module that depends\r\n * on the `ngMockE2E` and your application modules and defines the fake backend:\r\n *\r\n * ```js\r\n *   var myAppDev = angular.module('myAppDev', ['myApp', 'ngMockE2E']);\r\n *   myAppDev.run(function($httpBackend) {\r\n *     var phones = [{name: 'phone1'}, {name: 'phone2'}];\r\n *\r\n *     // returns the current list of phones\r\n *     $httpBackend.whenGET('/phones').respond(phones);\r\n *\r\n *     // adds a new phone to the phones array\r\n *     $httpBackend.whenPOST('/phones').respond(function(method, url, data) {\r\n *       var phone = angular.fromJson(data);\r\n *       phones.push(phone);\r\n *       return [200, phone, {}];\r\n *     });\r\n *     $httpBackend.whenGET(/^\\/templates\\//).passThrough(); // Requests for templates are handled by the real server\r\n *     //...\r\n *   });\r\n * ```\r\n *\r\n * Afterwards, bootstrap your app with this new module.\r\n *\r\n * ## Example\r\n * <example name=\"httpbackend-e2e-testing\" module=\"myAppE2E\" deps=\"angular-mocks.js\">\r\n * <file name=\"app.js\">\r\n *   var myApp = angular.module('myApp', []);\r\n *\r\n *   myApp.controller('MainCtrl', function MainCtrl($http) {\r\n *     var ctrl = this;\r\n *\r\n *     ctrl.phones = [];\r\n *     ctrl.newPhone = {\r\n *       name: ''\r\n *     };\r\n *\r\n *     ctrl.getPhones = function() {\r\n *       $http.get('/phones').then(function(response) {\r\n *         ctrl.phones = response.data;\r\n *       });\r\n *     };\r\n *\r\n *     ctrl.addPhone = function(phone) {\r\n *       $http.post('/phones', phone).then(function() {\r\n *         ctrl.newPhone = {name: ''};\r\n *         return ctrl.getPhones();\r\n *       });\r\n *     };\r\n *\r\n *     ctrl.getPhones();\r\n *   });\r\n * </file>\r\n * <file name=\"e2e.js\">\r\n *   var myAppDev = angular.module('myAppE2E', ['myApp', 'ngMockE2E']);\r\n *\r\n *   myAppDev.run(function($httpBackend) {\r\n *     var phones = [{name: 'phone1'}, {name: 'phone2'}];\r\n *\r\n *     // returns the current list of phones\r\n *     $httpBackend.whenGET('/phones').respond(phones);\r\n *\r\n *     // adds a new phone to the phones array\r\n *     $httpBackend.whenPOST('/phones').respond(function(method, url, data) {\r\n *       var phone = angular.fromJson(data);\r\n *       phones.push(phone);\r\n *       return [200, phone, {}];\r\n *     });\r\n *   });\r\n * </file>\r\n * <file name=\"index.html\">\r\n *   <div ng-controller=\"MainCtrl as $ctrl\">\r\n *   <form name=\"newPhoneForm\" ng-submit=\"$ctrl.addPhone($ctrl.newPhone)\">\r\n *     <input type=\"text\" ng-model=\"$ctrl.newPhone.name\">\r\n *     <input type=\"submit\" value=\"Add Phone\">\r\n *   </form>\r\n *   <h1>Phones</h1>\r\n *   <ul>\r\n *     <li ng-repeat=\"phone in $ctrl.phones\">{{phone.name}}</li>\r\n *   </ul>\r\n *   </div>\r\n * </file>\r\n * </example>\r\n *\r\n *\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#when\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition.\r\n *\r\n * @param {string} method HTTP method.\r\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\r\n *   data string and returns true if the data is as expected.\r\n * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header\r\n *   object and returns true if the headers match the current definition.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n *\r\n *  - respond \r\n *    ```\r\n *    { function([status,] data[, headers, statusText])\r\n *    | function(function(method, url, data, headers, params)}\r\n *    ```\r\n *     The respond method takes a set of static data to be returned or a function that can return\r\n *    an array containing response status (number), response data (Array|Object|string), response\r\n *    headers (Object), and the text for the status (string).\r\n *  - passThrough  `{function()}`  Any request matching a backend definition with\r\n *    `passThrough` handler will be passed through to the real backend (an XHR request will be made\r\n *    to the server.)\r\n *  - Both methods return the `requestHandler` object for possible overrides.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenGET\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition for GET requests. For more info see `when()`.\r\n *\r\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(Object|function(Object))=} headers HTTP headers.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenHEAD\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition for HEAD requests. For more info see `when()`.\r\n *\r\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(Object|function(Object))=} headers HTTP headers.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenDELETE\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition for DELETE requests. For more info see `when()`.\r\n *\r\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(Object|function(Object))=} headers HTTP headers.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenPOST\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition for POST requests. For more info see `when()`.\r\n *\r\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\r\n *   data string and returns true if the data is as expected.\r\n * @param {(Object|function(Object))=} headers HTTP headers.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenPUT\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition for PUT requests.  For more info see `when()`.\r\n *\r\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\r\n *   data string and returns true if the data is as expected.\r\n * @param {(Object|function(Object))=} headers HTTP headers.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenPATCH\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition for PATCH requests.  For more info see `when()`.\r\n *\r\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\r\n *   data string and returns true if the data is as expected.\r\n * @param {(Object|function(Object))=} headers HTTP headers.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenJSONP\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition for JSONP requests. For more info see `when()`.\r\n *\r\n * @param {string|RegExp|function(string)=} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenRoute\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition that compares only with the requested route.\r\n *\r\n * @param {string} method HTTP method.\r\n * @param {string} url HTTP url string that supports colon param matching.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\nangular.mock.e2e = {};\r\nangular.mock.e2e.$httpBackendDecorator =\r\n  ['$rootScope', '$timeout', '$delegate', '$browser', createHttpBackendMock];\r\n\r\n\r\n/**\r\n * @ngdoc type\r\n * @name $rootScope.Scope\r\n * @module ngMock\r\n * @description\r\n * {@link ng.$rootScope.Scope Scope} type decorated with helper methods useful for testing. These\r\n * methods are automatically available on any {@link ng.$rootScope.Scope Scope} instance when\r\n * `ngMock` module is loaded.\r\n *\r\n * In addition to all the regular `Scope` methods, the following helper methods are available:\r\n */\r\nangular.mock.$RootScopeDecorator = ['$delegate', function($delegate) {\r\n\r\n  var $rootScopePrototype = Object.getPrototypeOf($delegate);\r\n\r\n  $rootScopePrototype.$countChildScopes = countChildScopes;\r\n  $rootScopePrototype.$countWatchers = countWatchers;\r\n\r\n  return $delegate;\r\n\r\n  // ------------------------------------------------------------------------------------------ //\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $rootScope.Scope#$countChildScopes\r\n   * @module ngMock\r\n   * @this $rootScope.Scope\r\n   * @description\r\n   * Counts all the direct and indirect child scopes of the current scope.\r\n   *\r\n   * The current scope is excluded from the count. The count includes all isolate child scopes.\r\n   *\r\n   * @returns {number} Total number of child scopes.\r\n   */\r\n  function countChildScopes() {\r\n    var count = 0; // exclude the current scope\r\n    var pendingChildHeads = [this.$$childHead];\r\n    var currentScope;\r\n\r\n    while (pendingChildHeads.length) {\r\n      currentScope = pendingChildHeads.shift();\r\n\r\n      while (currentScope) {\r\n        count += 1;\r\n        pendingChildHeads.push(currentScope.$$childHead);\r\n        currentScope = currentScope.$$nextSibling;\r\n      }\r\n    }\r\n\r\n    return count;\r\n  }\r\n\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $rootScope.Scope#$countWatchers\r\n   * @this $rootScope.Scope\r\n   * @module ngMock\r\n   * @description\r\n   * Counts all the watchers of direct and indirect child scopes of the current scope.\r\n   *\r\n   * The watchers of the current scope are included in the count and so are all the watchers of\r\n   * isolate child scopes.\r\n   *\r\n   * @returns {number} Total number of watchers.\r\n   */\r\n  function countWatchers() {\r\n    var count = this.$$watchers ? this.$$watchers.length : 0; // include the current scope\r\n    var pendingChildHeads = [this.$$childHead];\r\n    var currentScope;\r\n\r\n    while (pendingChildHeads.length) {\r\n      currentScope = pendingChildHeads.shift();\r\n\r\n      while (currentScope) {\r\n        count += currentScope.$$watchers ? currentScope.$$watchers.length : 0;\r\n        pendingChildHeads.push(currentScope.$$childHead);\r\n        currentScope = currentScope.$$nextSibling;\r\n      }\r\n    }\r\n\r\n    return count;\r\n  }\r\n}];\r\n\r\n\r\n(function(jasmineOrMocha) {\r\n\r\n  if (!jasmineOrMocha) {\r\n    return;\r\n  }\r\n\r\n  var currentSpec = null,\r\n      injectorState = new InjectorState(),\r\n      annotatedFunctions = [],\r\n      wasInjectorCreated = function() {\r\n        return !!currentSpec;\r\n      };\r\n\r\n  angular.mock.$$annotate = angular.injector.$$annotate;\r\n  angular.injector.$$annotate = function(fn) {\r\n    if (typeof fn === 'function' && !fn.$inject) {\r\n      annotatedFunctions.push(fn);\r\n    }\r\n    return angular.mock.$$annotate.apply(this, arguments);\r\n  };\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name angular.mock.module\r\n   * @description\r\n   *\r\n   * *NOTE*: This function is also published on window for easy access.<br>\r\n   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha\r\n   *\r\n   * This function registers a module configuration code. It collects the configuration information\r\n   * which will be used when the injector is created by {@link angular.mock.inject inject}.\r\n   *\r\n   * See {@link angular.mock.inject inject} for usage example\r\n   *\r\n   * @param {...(string|Function|Object)} fns any number of modules which are represented as string\r\n   *        aliases or as anonymous module initialization functions. The modules are used to\r\n   *        configure the injector. The 'ng' and 'ngMock' modules are automatically loaded. If an\r\n   *        object literal is passed each key-value pair will be registered on the module via\r\n   *        {@link auto.$provide $provide}.value, the key being the string name (or token) to associate\r\n   *        with the value on the injector.\r\n   */\r\n  var module = window.module = angular.mock.module = function() {\r\n    var moduleFns = Array.prototype.slice.call(arguments, 0);\r\n    return wasInjectorCreated() ? workFn() : workFn;\r\n    /////////////////////\r\n    function workFn() {\r\n      if (currentSpec.$injector) {\r\n        throw new Error('Injector already created, can not register a module!');\r\n      } else {\r\n        var fn, modules = currentSpec.$modules || (currentSpec.$modules = []);\r\n        angular.forEach(moduleFns, function(module) {\r\n          if (angular.isObject(module) && !angular.isArray(module)) {\r\n            fn = ['$provide', function($provide) {\r\n              angular.forEach(module, function(value, key) {\r\n                $provide.value(key, value);\r\n              });\r\n            }];\r\n          } else {\r\n            fn = module;\r\n          }\r\n          if (currentSpec.$providerInjector) {\r\n            currentSpec.$providerInjector.invoke(fn);\r\n          } else {\r\n            modules.push(fn);\r\n          }\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  module.$$beforeAllHook = (window.before || window.beforeAll);\r\n  module.$$afterAllHook = (window.after || window.afterAll);\r\n\r\n  // purely for testing ngMock itself\r\n  module.$$currentSpec = function(to) {\r\n    if (arguments.length === 0) return to;\r\n    currentSpec = to;\r\n  };\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name angular.mock.module.sharedInjector\r\n   * @description\r\n   *\r\n   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha\r\n   *\r\n   * This function ensures a single injector will be used for all tests in a given describe context.\r\n   * This contrasts with the default behaviour where a new injector is created per test case.\r\n   *\r\n   * Use sharedInjector when you want to take advantage of Jasmine's `beforeAll()`, or mocha's\r\n   * `before()` methods. Call `module.sharedInjector()` before you setup any other hooks that\r\n   * will create (i.e call `module()`) or use (i.e call `inject()`) the injector.\r\n   *\r\n   * You cannot call `sharedInjector()` from within a context already using `sharedInjector()`.\r\n   *\r\n   * ## Example\r\n   *\r\n   * Typically beforeAll is used to make many assertions about a single operation. This can\r\n   * cut down test run-time as the test setup doesn't need to be re-run, and enabling focussed\r\n   * tests each with a single assertion.\r\n   *\r\n   * ```js\r\n   * describe(\"Deep Thought\", function() {\r\n   *\r\n   *   module.sharedInjector();\r\n   *\r\n   *   beforeAll(module(\"UltimateQuestion\"));\r\n   *\r\n   *   beforeAll(inject(function(DeepThought) {\r\n   *     expect(DeepThought.answer).toBeUndefined();\r\n   *     DeepThought.generateAnswer();\r\n   *   }));\r\n   *\r\n   *   it(\"has calculated the answer correctly\", inject(function(DeepThought) {\r\n   *     // Because of sharedInjector, we have access to the instance of the DeepThought service\r\n   *     // that was provided to the beforeAll() hook. Therefore we can test the generated answer\r\n   *     expect(DeepThought.answer).toBe(42);\r\n   *   }));\r\n   *\r\n   *   it(\"has calculated the answer within the expected time\", inject(function(DeepThought) {\r\n   *     expect(DeepThought.runTimeMillennia).toBeLessThan(8000);\r\n   *   }));\r\n   *\r\n   *   it(\"has double checked the answer\", inject(function(DeepThought) {\r\n   *     expect(DeepThought.absolutelySureItIsTheRightAnswer).toBe(true);\r\n   *   }));\r\n   *\r\n   * });\r\n   *\r\n   * ```\r\n   */\r\n  module.sharedInjector = function() {\r\n    if (!(module.$$beforeAllHook && module.$$afterAllHook)) {\r\n      throw Error('sharedInjector() cannot be used unless your test runner defines beforeAll/afterAll');\r\n    }\r\n\r\n    var initialized = false;\r\n\r\n    module.$$beforeAllHook(/** @this */ function() {\r\n      if (injectorState.shared) {\r\n        injectorState.sharedError = Error('sharedInjector() cannot be called inside a context that has already called sharedInjector()');\r\n        throw injectorState.sharedError;\r\n      }\r\n      initialized = true;\r\n      currentSpec = this;\r\n      injectorState.shared = true;\r\n    });\r\n\r\n    module.$$afterAllHook(function() {\r\n      if (initialized) {\r\n        injectorState = new InjectorState();\r\n        module.$$cleanup();\r\n      } else {\r\n        injectorState.sharedError = null;\r\n      }\r\n    });\r\n  };\r\n\r\n  module.$$beforeEach = function() {\r\n    if (injectorState.shared && currentSpec && currentSpec !== this) {\r\n      var state = currentSpec;\r\n      currentSpec = this;\r\n      angular.forEach(['$injector','$modules','$providerInjector', '$injectorStrict'], function(k) {\r\n        currentSpec[k] = state[k];\r\n        state[k] = null;\r\n      });\r\n    } else {\r\n      currentSpec = this;\r\n      originalRootElement = null;\r\n      annotatedFunctions = [];\r\n    }\r\n  };\r\n\r\n  module.$$afterEach = function() {\r\n    if (injectorState.cleanupAfterEach()) {\r\n      module.$$cleanup();\r\n    }\r\n  };\r\n\r\n  module.$$cleanup = function() {\r\n    var injector = currentSpec.$injector;\r\n\r\n    annotatedFunctions.forEach(function(fn) {\r\n      delete fn.$inject;\r\n    });\r\n\r\n    currentSpec.$injector = null;\r\n    currentSpec.$modules = null;\r\n    currentSpec.$providerInjector = null;\r\n    currentSpec = null;\r\n\r\n    if (injector) {\r\n      // Ensure `$rootElement` is instantiated, before checking `originalRootElement`\r\n      var $rootElement = injector.get('$rootElement');\r\n      var rootNode = $rootElement && $rootElement[0];\r\n      var cleanUpNodes = !originalRootElement ? [] : [originalRootElement[0]];\r\n      if (rootNode && (!originalRootElement || rootNode !== originalRootElement[0])) {\r\n        cleanUpNodes.push(rootNode);\r\n      }\r\n      angular.element.cleanData(cleanUpNodes);\r\n\r\n      // Ensure `$destroy()` is available, before calling it\r\n      // (a mocked `$rootScope` might not implement it (or not even be an object at all))\r\n      var $rootScope = injector.get('$rootScope');\r\n      if ($rootScope && $rootScope.$destroy) $rootScope.$destroy();\r\n    }\r\n\r\n    // clean up jquery's fragment cache\r\n    angular.forEach(angular.element.fragments, function(val, key) {\r\n      delete angular.element.fragments[key];\r\n    });\r\n\r\n    MockXhr.$$lastInstance = null;\r\n\r\n    angular.forEach(angular.callbacks, function(val, key) {\r\n      delete angular.callbacks[key];\r\n    });\r\n    angular.callbacks.$$counter = 0;\r\n  };\r\n\r\n  (window.beforeEach || window.setup)(module.$$beforeEach);\r\n  (window.afterEach || window.teardown)(module.$$afterEach);\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name angular.mock.inject\r\n   * @description\r\n   *\r\n   * *NOTE*: This function is also published on window for easy access.<br>\r\n   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha\r\n   *\r\n   * The inject function wraps a function into an injectable function. The inject() creates new\r\n   * instance of {@link auto.$injector $injector} per test, which is then used for\r\n   * resolving references.\r\n   *\r\n   *\r\n   * ## Resolving References (Underscore Wrapping)\r\n   * Often, we would like to inject a reference once, in a `beforeEach()` block and reuse this\r\n   * in multiple `it()` clauses. To be able to do this we must assign the reference to a variable\r\n   * that is declared in the scope of the `describe()` block. Since we would, most likely, want\r\n   * the variable to have the same name of the reference we have a problem, since the parameter\r\n   * to the `inject()` function would hide the outer variable.\r\n   *\r\n   * To help with this, the injected parameters can, optionally, be enclosed with underscores.\r\n   * These are ignored by the injector when the reference name is resolved.\r\n   *\r\n   * For example, the parameter `_myService_` would be resolved as the reference `myService`.\r\n   * Since it is available in the function body as `_myService_`, we can then assign it to a variable\r\n   * defined in an outer scope.\r\n   *\r\n   * ```\r\n   * // Defined out reference variable outside\r\n   * var myService;\r\n   *\r\n   * // Wrap the parameter in underscores\r\n   * beforeEach( inject( function(_myService_){\r\n   *   myService = _myService_;\r\n   * }));\r\n   *\r\n   * // Use myService in a series of tests.\r\n   * it('makes use of myService', function() {\r\n   *   myService.doStuff();\r\n   * });\r\n   *\r\n   * ```\r\n   *\r\n   * See also {@link angular.mock.module angular.mock.module}\r\n   *\r\n   * ## Example\r\n   * Example of what a typical jasmine tests looks like with the inject method.\r\n   * ```js\r\n   *\r\n   *   angular.module('myApplicationModule', [])\r\n   *       .value('mode', 'app')\r\n   *       .value('version', 'v1.0.1');\r\n   *\r\n   *\r\n   *   describe('MyApp', function() {\r\n   *\r\n   *     // You need to load modules that you want to test,\r\n   *     // it loads only the \"ng\" module by default.\r\n   *     beforeEach(module('myApplicationModule'));\r\n   *\r\n   *\r\n   *     // inject() is used to inject arguments of all given functions\r\n   *     it('should provide a version', inject(function(mode, version) {\r\n   *       expect(version).toEqual('v1.0.1');\r\n   *       expect(mode).toEqual('app');\r\n   *     }));\r\n   *\r\n   *\r\n   *     // The inject and module method can also be used inside of the it or beforeEach\r\n   *     it('should override a version and test the new version is injected', function() {\r\n   *       // module() takes functions or strings (module aliases)\r\n   *       module(function($provide) {\r\n   *         $provide.value('version', 'overridden'); // override version here\r\n   *       });\r\n   *\r\n   *       inject(function(version) {\r\n   *         expect(version).toEqual('overridden');\r\n   *       });\r\n   *     });\r\n   *   });\r\n   *\r\n   * ```\r\n   *\r\n   * @param {...Function} fns any number of functions which will be injected using the injector.\r\n   */\r\n\r\n\r\n\r\n  var ErrorAddingDeclarationLocationStack = function ErrorAddingDeclarationLocationStack(e, errorForStack) {\r\n    this.message = e.message;\r\n    this.name = e.name;\r\n    if (e.line) this.line = e.line;\r\n    if (e.sourceId) this.sourceId = e.sourceId;\r\n    if (e.stack && errorForStack)\r\n      this.stack = e.stack + '\\n' + errorForStack.stack;\r\n    if (e.stackArray) this.stackArray = e.stackArray;\r\n  };\r\n  ErrorAddingDeclarationLocationStack.prototype = Error.prototype;\r\n\r\n  window.inject = angular.mock.inject = function() {\r\n    var blockFns = Array.prototype.slice.call(arguments, 0);\r\n    var errorForStack = new Error('Declaration Location');\r\n    // IE10+ and PhanthomJS do not set stack trace information, until the error is thrown\r\n    if (!errorForStack.stack) {\r\n      try {\r\n        throw errorForStack;\r\n      } catch (e) { /* empty */ }\r\n    }\r\n    return wasInjectorCreated() ? WorkFn.call(currentSpec) : WorkFn;\r\n    /////////////////////\r\n    function WorkFn() {\r\n      var modules = currentSpec.$modules || [];\r\n      var strictDi = !!currentSpec.$injectorStrict;\r\n      modules.unshift(['$injector', function($injector) {\r\n        currentSpec.$providerInjector = $injector;\r\n      }]);\r\n      modules.unshift('ngMock');\r\n      modules.unshift('ng');\r\n      var injector = currentSpec.$injector;\r\n      if (!injector) {\r\n        if (strictDi) {\r\n          // If strictDi is enabled, annotate the providerInjector blocks\r\n          angular.forEach(modules, function(moduleFn) {\r\n            if (typeof moduleFn === 'function') {\r\n              angular.injector.$$annotate(moduleFn);\r\n            }\r\n          });\r\n        }\r\n        injector = currentSpec.$injector = angular.injector(modules, strictDi);\r\n        currentSpec.$injectorStrict = strictDi;\r\n      }\r\n      for (var i = 0, ii = blockFns.length; i < ii; i++) {\r\n        if (currentSpec.$injectorStrict) {\r\n          // If the injector is strict / strictDi, and the spec wants to inject using automatic\r\n          // annotation, then annotate the function here.\r\n          injector.annotate(blockFns[i]);\r\n        }\r\n        try {\r\n          injector.invoke(blockFns[i] || angular.noop, this);\r\n        } catch (e) {\r\n          if (e.stack && errorForStack) {\r\n            throw new ErrorAddingDeclarationLocationStack(e, errorForStack);\r\n          }\r\n          throw e;\r\n        } finally {\r\n          errorForStack = null;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  angular.mock.inject.strictDi = function(value) {\r\n    value = arguments.length ? !!value : true;\r\n    return wasInjectorCreated() ? workFn() : workFn;\r\n\r\n    function workFn() {\r\n      if (value !== currentSpec.$injectorStrict) {\r\n        if (currentSpec.$injector) {\r\n          throw new Error('Injector already created, can not modify strict annotations');\r\n        } else {\r\n          currentSpec.$injectorStrict = value;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  function InjectorState() {\r\n    this.shared = false;\r\n    this.sharedError = null;\r\n\r\n    this.cleanupAfterEach = function() {\r\n      return !this.shared || this.sharedError;\r\n    };\r\n  }\r\n})(window.jasmine || window.mocha);\r\n\r\n'use strict';\r\n\r\n(function() {\r\n  /**\r\n   * Triggers a browser event. Attempts to choose the right event if one is\r\n   * not specified.\r\n   *\r\n   * @param {Object} element Either a wrapped jQuery/jqLite node or a DOMElement\r\n   * @param {string} eventType Optional event type\r\n   * @param {Object=} eventData An optional object which contains additional event data (such as x,y\r\n   * coordinates, keys, etc...) that are passed into the event when triggered\r\n   */\r\n  window.browserTrigger = function browserTrigger(element, eventType, eventData) {\r\n    if (element && !element.nodeName) element = element[0];\r\n    if (!element) return;\r\n\r\n    eventData = eventData || {};\r\n    var relatedTarget = eventData.relatedTarget || element;\r\n    var keys = eventData.keys;\r\n    var x = eventData.x;\r\n    var y = eventData.y;\r\n\r\n    var inputType = (element.type) ? element.type.toLowerCase() : null,\r\n        nodeName = element.nodeName.toLowerCase();\r\n    if (!eventType) {\r\n      eventType = {\r\n        'text':            'change',\r\n        'textarea':        'change',\r\n        'hidden':          'change',\r\n        'password':        'change',\r\n        'button':          'click',\r\n        'submit':          'click',\r\n        'reset':           'click',\r\n        'image':           'click',\r\n        'checkbox':        'click',\r\n        'radio':           'click',\r\n        'select-one':      'change',\r\n        'select-multiple': 'change',\r\n        '_default_':       'click'\r\n      }[inputType || '_default_'];\r\n    }\r\n\r\n    if (nodeName === 'option') {\r\n      element.parentNode.value = element.value;\r\n      element = element.parentNode;\r\n      eventType = 'change';\r\n    }\r\n\r\n    keys = keys || [];\r\n    function pressed(key) {\r\n      return keys.indexOf(key) !== -1;\r\n    }\r\n\r\n    var evnt;\r\n    if (/transitionend/.test(eventType)) {\r\n      if (window.WebKitTransitionEvent) {\r\n        evnt = new window.WebKitTransitionEvent(eventType, eventData);\r\n        evnt.initEvent(eventType, false, true);\r\n      } else {\r\n        try {\r\n          evnt = new window.TransitionEvent(eventType, eventData);\r\n        } catch (e) {\r\n          evnt = window.document.createEvent('TransitionEvent');\r\n          evnt.initTransitionEvent(eventType, null, null, null, eventData.elapsedTime || 0);\r\n        }\r\n      }\r\n    } else if (/animationend/.test(eventType)) {\r\n      if (window.WebKitAnimationEvent) {\r\n        evnt = new window.WebKitAnimationEvent(eventType, eventData);\r\n        evnt.initEvent(eventType, false, true);\r\n      } else {\r\n        try {\r\n          evnt = new window.AnimationEvent(eventType, eventData);\r\n        } catch (e) {\r\n          evnt = window.document.createEvent('AnimationEvent');\r\n          evnt.initAnimationEvent(eventType, null, null, null, eventData.elapsedTime || 0);\r\n        }\r\n      }\r\n    } else if (/touch/.test(eventType) && supportsTouchEvents()) {\r\n      evnt = createTouchEvent(element, eventType, x, y);\r\n    } else if (/key/.test(eventType)) {\r\n      evnt = window.document.createEvent('Events');\r\n      evnt.initEvent(eventType, eventData.bubbles, eventData.cancelable);\r\n      evnt.view = window;\r\n      evnt.ctrlKey = pressed('ctrl');\r\n      evnt.altKey = pressed('alt');\r\n      evnt.shiftKey = pressed('shift');\r\n      evnt.metaKey = pressed('meta');\r\n      evnt.keyCode = eventData.keyCode;\r\n      evnt.charCode = eventData.charCode;\r\n      evnt.which = eventData.which;\r\n    } else {\r\n      evnt = window.document.createEvent('MouseEvents');\r\n      x = x || 0;\r\n      y = y || 0;\r\n      evnt.initMouseEvent(eventType, true, true, window, 0, x, y, x, y, pressed('ctrl'),\r\n          pressed('alt'), pressed('shift'), pressed('meta'), 0, relatedTarget);\r\n    }\r\n\r\n    /* we're unable to change the timeStamp value directly so this\r\n     * is only here to allow for testing where the timeStamp value is\r\n     * read */\r\n    evnt.$manualTimeStamp = eventData.timeStamp;\r\n\r\n    if (!evnt) return;\r\n\r\n    var originalPreventDefault = evnt.preventDefault,\r\n        appWindow = element.ownerDocument.defaultView,\r\n        fakeProcessDefault = true,\r\n        finalProcessDefault,\r\n        angular = appWindow.angular || {};\r\n\r\n    // igor: temporary fix for https://bugzilla.mozilla.org/show_bug.cgi?id=684208\r\n    angular['ff-684208-preventDefault'] = false;\r\n    evnt.preventDefault = function() {\r\n      fakeProcessDefault = false;\r\n      return originalPreventDefault.apply(evnt, arguments);\r\n    };\r\n\r\n    if (!eventData.bubbles || supportsEventBubblingInDetachedTree() || isAttachedToDocument(element)) {\r\n      element.dispatchEvent(evnt);\r\n    } else {\r\n      triggerForPath(element, evnt);\r\n    }\r\n\r\n    finalProcessDefault = !(angular['ff-684208-preventDefault'] || !fakeProcessDefault);\r\n\r\n    delete angular['ff-684208-preventDefault'];\r\n\r\n    return finalProcessDefault;\r\n  };\r\n\r\n  function supportsTouchEvents() {\r\n    if ('_cached' in supportsTouchEvents) {\r\n      return supportsTouchEvents._cached;\r\n    }\r\n    if (!window.document.createTouch || !window.document.createTouchList) {\r\n      supportsTouchEvents._cached = false;\r\n      return false;\r\n    }\r\n    try {\r\n      window.document.createEvent('TouchEvent');\r\n    } catch (e) {\r\n      supportsTouchEvents._cached = false;\r\n      return false;\r\n    }\r\n    supportsTouchEvents._cached = true;\r\n    return true;\r\n  }\r\n\r\n  function createTouchEvent(element, eventType, x, y) {\r\n    var evnt = new window.Event(eventType);\r\n    x = x || 0;\r\n    y = y || 0;\r\n\r\n    var touch = window.document.createTouch(window, element, Date.now(), x, y, x, y);\r\n    var touches = window.document.createTouchList(touch);\r\n\r\n    evnt.touches = touches;\r\n\r\n    return evnt;\r\n  }\r\n\r\n  function supportsEventBubblingInDetachedTree() {\r\n    if ('_cached' in supportsEventBubblingInDetachedTree) {\r\n      return supportsEventBubblingInDetachedTree._cached;\r\n    }\r\n    supportsEventBubblingInDetachedTree._cached = false;\r\n    var doc = window.document;\r\n    if (doc) {\r\n      var parent = doc.createElement('div'),\r\n          child = parent.cloneNode();\r\n      parent.appendChild(child);\r\n      parent.addEventListener('e', function() {\r\n        supportsEventBubblingInDetachedTree._cached = true;\r\n      });\r\n      var evnt = window.document.createEvent('Events');\r\n      evnt.initEvent('e', true, true);\r\n      child.dispatchEvent(evnt);\r\n    }\r\n    return supportsEventBubblingInDetachedTree._cached;\r\n  }\r\n\r\n  function triggerForPath(element, evnt) {\r\n    var stop = false;\r\n\r\n    var _stopPropagation = evnt.stopPropagation;\r\n    evnt.stopPropagation = function() {\r\n      stop = true;\r\n      _stopPropagation.apply(evnt, arguments);\r\n    };\r\n    patchEventTargetForBubbling(evnt, element);\r\n    do {\r\n      element.dispatchEvent(evnt);\r\n      // eslint-disable-next-line no-unmodified-loop-condition\r\n    } while (!stop && (element = element.parentNode));\r\n  }\r\n\r\n  function patchEventTargetForBubbling(event, target) {\r\n    event._target = target;\r\n    Object.defineProperty(event, 'target', {get: function() { return this._target;}});\r\n  }\r\n\r\n  function isAttachedToDocument(element) {\r\n    while ((element = element.parentNode)) {\r\n        if (element === window) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n  }\r\n})();\r\n\r\n\r\n})(window, window.angular);\r\n"]}